# CH06 데이터베이스

- [1. 데이터베이스의 큰 그림](#1-데이터베이스의-큰-그림)
= [2. RDBMS의 기본](#2-rdbms의-기본)
- [3. SQL](#3-sql)
- [4. 효율적 쿼리]()
- [5. 데이터베이스 설계]()
- [6. NoSQL]()

## 1. 데이터베이스의 큰 그림

### 데이터베이스와 DBMS

- `데이터베이스(DB)`: 여러 사람이 공유하고 사용할 수 있도록 체계적으로 저장·관리하는 데이터의 집합. (정보의 집합이라고 생각하자.)

- `DBMS(Database Management System)`: 데이터베이스를 생성, 관리, 운용하기 위한 소프트웨어.

웹 서비스의 성능과 정체성은 어떤 데이터를 어떻게 저장하느냐에 따라 달라짐.

- DBMS의 종류
| 구분        | 설명                               | 대표 제품                             |
| --------- | -------------------------------- | --------------------------------- |
| **RDBMS** | 테이블 기반의 정형화된 구조, **스키마 존재**      | MySQL, PostgreSQL, Oracle, SQLite |
| **NoSQL DBMS** | 비정형 데이터 저장 가능, **스키마 없음 또는 유연함** | MongoDB, Redis                    |

- `SQL(Structured Query Language)` : 데이터베이스를 다룰 때에 사용되는 언어 중 하나
    - `DDL(Data Definition Language)` : 데이터 정의  
    e.g. CREATE, ALTER, DROP, TRUNCATE
    - `DML(Data Manipulation Language)` : 데이터 조작
    e.g. SELECT, INSERT, UPDATE, DELETE
    - `DCL(Data Control Language)` : 데이터 제어 (작업 상태와 관련된)
    e.g. COMMIT, ROLLBACK, SAVEPOINT
    - `TCL(Transaction Control Language)` : 트랜잭션 제어  
    e.g. GRANT, REVOKE


> Q. `스키마(scheme)`란?
> - 테이블 구조를 정의하는 설계도  
> - 필드, 데이터 타입, 제약 조건 등 정의한 것

```sql
CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  email VARCHAR(100) UNIQUE,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

> Q. 스키마의 존재 유무가 끼치는 영향은? 
> 데이터 구조의 일관성 유지, 잘못된 데이터 입력 방지, 정형화된 쿼리 작성 가능

> Q. 왜 파일보다 DBMS를 사용할까요?
>
> (1) 데이터의 일관성 및 무결성을 유지하기 위해서입니다.  
> 특정 데이터에 동시 접속할 경우 레이스 컨디션이 발생할 수 있습니다.
>
> (2) 중복되는 저장이 많을 수 있습니다.  
> 동일 정보를 반복해서 저장할 경우 공간이 낭비됩니다.
>
> (3) 연관된 데이터의 변경이 어렵습니다.
> 관련된 파일들을 일일이 찾아 수정해야 합니다.
>
> (4) 백업 및 복구가 어렵습니다.  
> 장애가 발생했을 경우 복구가 힘듭니다.

### 데이터베이스의 저장 단위

- `엔티티 (Entity)` : 저장 가능한 독립 객체, 집합이라기 보다는 하나 하나의 구성 요소 e.g. 학생, 제품, 구매자
- `엔티티 집합` : 같은 속성을 공유하는 엔티티 모음
- `속성 (Attribute)` : 엔티티의 특성 e.g. 이름, 나이, 제품번호 등
- `도메인 (Domain)` : 속성이 가질 수 있는 값의 집합 e.g. 성별이라는 속성의 도메인은 {남자, 여자}
- `레코드 (Record)` : 저장된 엔티티(DB에 기록된 값)
- `필드 (Field)` : 레코드의 속성
- `차수(degree)` : 필드의 수, 필드의 총 개수
- `카디널리티(cardinality)` : 한 필드에 대한 고유 값의 수 e.g. 성별이라는 필드의 카디널리티는 2 이다.
- `릴레이션 (Relation)` : 테이블 구조로 표현된 엔티티 집합 e.g. SQL 테이블  
`+` NoSQL에서는 `컬렉션(collection)`이라는 단위로 표현


> 엔티티는 저장 가능한 대상, 레코드는 저장된 대상

### 트랜잭션과 ACID

- `트랜잭션 (Transaction)` : DB에서 하나의 논리적 작업 단위
    - `TPS` : 초당 트랜잭션 처리 수, 성능 지표로 활용

- `ACID` : 트랜잭션의 핵심 특징(원자성, 일관성, 격리성, 지속성)

| 속성                        | 설명                              | 예시                    |
| ------------------------- | ------------------------------- | --------------------- |
| **A - 원자성 (Atomicity)**   | 모두 성공하거나 모두 실패 (All or Nothing) | 송금 중 실패 시, 출금도 롤백     |
| **C - 일관성 (Consistency)** | 트랜잭션 전후 데이터 일관된 상태 유지           | 학과 인원수 +1 일관성 유지      |
| **I - 격리성 (Isolation)**   | 동시 수행 트랜잭션 간 간섭 방지              | 같은 재고 상품 2명이 동시에 구매 X |
| **D - 지속성 (Durability)**  | 완료된 트랜잭션 결과는 영구 저장              | 전기 꺼져도 입금 내용 보존됨      |

> 쉽게 외워보기
> 1. 원자성(Atomicity)
> Atomic = 더 쪼갤 수 없는
> 원자처럼 하나의 단위로 처리되는 성질이다.
> 트랜잭션은 하나의 원자처럼 하나의 트랜잭션이 다 처리되거나, 다 처리가 안 되거나!
> 
> 2. 일관성(Consistency)
> 일관성 = 앞뒤가 맞고 규칙을 지킨다.
> 어떤 작업을 해도 데이터는 항상 정해진 규칙을 만족해야한다.
> e.g. 일관성은 최종적인 결과에 관한 것인듯 => A가 50만원 출금 -> B에게 50만원 송금하면 A + B는 여전히 유지되어야한다! 
> 
> 3. 격리성(Isolation)
> 격리 = 따로 떨어져 있다.
> 동시에 여러 트랜잭션이 실행되더라도 서로 간섭하지 않도록 처리해야한다.
> 
> 4. 지속성(Durability)
> 지속 = 오래 간다, 남아 있다.
> 트랜잭션이 성공적으로 끝났다면 그 결과는 어떠한 상황에서도 보존되어야 한다.

## 2 RDBMS의 기본

필드 타입, 키, 무결성 제약 조건, 테이블 간 관계

### 테이블의 구성: 필드와 레코드

- 용어 정리
    - `테이블(Table)`: RDBMS에서 데이터를 저장하는 기본 단위. 행(Row, Record)과 열(Column, Field)로 구성
    - `필드(Field)`: 컬럼(열), 한 속성(attribute)을 나타냄. 예: 이름, 나이
    - `레코드(Record)`: 행. 실제 데이터 한 줄(실제로 저장된 데이터)
---

- 필드 타입(Field Type) : 다양한 필드 타입이 존재하며, 테이블을 생성할 때에 각 필드에 필드 타입을 지정한다.

| 분류     | 예시                          |
| ------ | --------------------------- |
| 숫자형    | INT, FLOAT, DOUBLE, DECIMAL |
| 문자형    | CHAR, VARCHAR, TEXT         |
| 날짜/시간형 | DATE, TIME, DATETIME        |
| 기타     | BOOLEAN, BLOB               |

```sql
CREATE TABLE Student (
  student_id INT,
  name VARCHAR(50),
  email VARCHAR(100),
  birth_date DATE
);

```

### 키(Key)

테이블의 레코드를 식별할 수 있는 하나 이상의 필드

- `후보 키(Candidate Key)` : 레코드를 식별할 수 있는 최소 필드 집합, 여러 개일 수도 있다. (기본키 + 대체키) 

- `기본 키(Primary Key)` : 후보 키 중에서 대표로 선택된 키, 테이블 당 하나만 존재하며, NULL 및 중복은 불가하다!

- `대체 키(Alternate Key)` : 기본 키가 아닌 나머지 후보 키

- `외래 키(Foreign Key)` : 다른 테이블의 기본 키를 참조하는 필드이다. 참조 관계 형성 시에 사용

- `슈퍼 키(Super Key)` : 유일성은 만족하나 최소성은 만족하지 않는 키이다.  
    (student_id + name과 같이 레코드를 유일하게 식별할 수 있지만, 최소한의 정보만 가지고 있는 것은 아니다.)

- `복합 키(Composite Key)` : 두 개 이상의 컬럼으로 구성된 키, 후보키 중에서 두 개 이상의 컬럼으로 구성된 키

> **유일성과 최소성**
> `유일성` : 특정 레코드를 유일하게 식별한다. => 유일성을 갖추었다.
>
> `최소성` : 최소한의 정보로 레코드를 식별한다. => 최소성을 갖추었다.

```sql
CREATE TABLE Student (
  student_id INT PRIMARY KEY, -- student_id는 후보 키 이면서 기본 키
  email VARCHAR(100) UNIQUE,
  phone VARCHAR(20)
);
```

```sql
CREATE TABLE Score (
  student_id INT,
  subject_code VARCHAR(10),
  year INT,
  grade CHAR(1),
  PRIMARY KEY (student_id, subject_code), -- 복합 키
  FOREIGN KEY (student_id) REFERENCES Student(student_id) 
);
```

### 테이블 간 관계

외래 키를 매개로 하는 테이블 간 연관 관계

- `1:1 (일대일) 대응` : 한 레코드가 다른 테이블의 한 레코드에만 대응된다.  
    e.g. 승객은 각자 하나의 여권만 가질 수 있다.

- `1:N (일대다) 대응` : 한 레코드가 다른 테이블의 여러 레코드에 대응된다.  
    e.g. 영화 하나에 여러 사람이 댓글을 남길 수 있다.

- `N:M (다대다) 대응` : 여러 레코드가 다른 테이블의 여러 레코드에 대응된다. 일반적으로 중간 테이블을 가진다.  
    e.g. SNS에서는 여러 사람이 서로를 팔로우하고 있다.

```sql
CREATE TABLE User (
  user_id INT PRIMARY KEY,
  name VARCHAR(50)
);

CREATE TABLE Group (
  group_id INT PRIMARY KEY,
  group_name VARCHAR(50)
);

CREATE TABLE UserGroup (
  user_id INT,
  group_id INT,
  PRIMARY KEY(user_id, group_id),
  FOREIGN KEY(user_id) REFERENCES User(user_id),
  FOREIGN KEY(group_id) REFERENCES Group(group_id)
);

```

### 무결성 제약 조건

- `무결성` : 일관되며 유효한 데이터의 상태 (문제가 없는, 무결한 상태)
- `무결성 제약 조건` : 데이터베이스에 저장된 데이터의 <u>일관성(특정 규칙을 지키는 상태)과 유효성(=무결성)</u>유지하기 위해 지켜야 하는 조건

    - `도메인 제약 조건(domain constraint)`  
        테이블이 가질 수 있는 필드 타입과 범위에 대한 규칙입니다. 
        각각의 필드 데이터는 원자 값을 가지며, 필드 타입을 준수해야한다.
        
        > `+` `원자 값(atomic value)` : 더 이상 쪼갤 수 없는 단일한 값
        >
        > e.g.  
        > ("김지영", 23, "여") => 각각의 필드 데이터는 원자
        > ["김지영, 23, 여"] => 한 필드에 들어가 있는 정보가 쪼개질 수 있음 

    - `키 제약 조건(key constraint)`  
        키로 지정된 필드에 중복된 값이 존재해서는 안 된다 (중복되면 유일하게 식별할 수 없음)

    - `엔티티 무결성 제약 조건(entity integrity constraint, 기본 키 제약 조건)`  
        기본 키로 지정한 필드는 고유한 값이며, NULL이 되어서는 안 된다

    - `참조 무결성 제약 조건(referential integrity constraint, 외래 키 제약 조건)`  
        외래 키는 참조하는 테이블의 기본 키와 같은 값을 갖거나 NULL값을 가져야 한다

> 참조하는 테이블이 삭제/수정되는 경우
>
> 영화에 여러 댓글이 작성되어 있다. 댓글 테이블이 영화 테이블을 참조하고 있다.  
> 이 때에 영화가 삭제되는 경우에는 이를 참조하는 댓글 테이블은 어떻게 될까?
> ➊ 연산 제한(RESTRICT)  
> 주어진 수정 및 삭제 연산 자체를 거부한다. => 영화 삭제 불가능
> ➋ 기본값 설정(SET DEFAULT)  
> 참조하는 레코드를 미리 지정한 기본값으로 설정한다.
> ➌ NULL 값 설정(SET NULL)  
> 참조하는 레코드를 NULL로 설정한다. => 댓글에 해당하는 영화에 NULL이 들어간다.
> ➍ 연쇄 변경(CASCADE)  
참조하는 레코드도 함께 수정되거나 삭제한다. => 영화가 삭제되면 거기에 달린 댓글들도 함께 삭제된다.

```sql
CREATE TABLE Enrollment (
  student_id INT,
  course_id INT,
  PRIMARY KEY(student_id, course_id),
  FOREIGN KEY(student_id) REFERENCES Student(student_id) ON DELETE CASCADE
);

```


## 3 SQL

`데이터 정의 언어(DDL)`, `데이터 조작 언어(DML)`, `데이터 제어 언어(DCL)`, `트랜잭션 제어 언어(TCL)`

| 분류   | 설명   | 주요 명령어   | 예시 |
| ------------ | ------ | -------- | -------- |
| **DDL**<br>(Data Definition Language)  | 데이터베이스 **구조 정의**  | `CREATE`, `ALTER`, `DROP`, `TRUNCATE`, `RENAME`   | `CREATE TABLE users ( id INT PRIMARY KEY, name VARCHAR(50) );`<br>`ALTER TABLE users ADD email VARCHAR(100);`<br>`DROP TABLE users;`          |
| **DML**<br>(Data Manipulation Language)   | 테이블 내 **데이터 조작**   | `SELECT`, `INSERT`, `UPDATE`, `DELETE`    | `SELECT * FROM users;`<br>`INSERT INTO users (id, name) VALUES (1, 'Alice');`<br>`UPDATE users SET name = 'Bob' WHERE id = 1;`<br>`DELETE FROM users WHERE id = 1;` |
| **DCL**<br>(Data Control Language)   | 사용자에 대한 **권한 제어**   | `GRANT`, `REVOKE`   | `GRANT SELECT ON users TO user1;`<br>`REVOKE SELECT ON users FROM user1;`   |
| **TCL**<br>(Transaction Control Language) | 트랜잭션 처리 및 **일괄 작업 제어** | `COMMIT`, `ROLLBACK`, `SAVEPOINT`, `SET TRANSACTION` | `BEGIN;`<br>`UPDATE users SET name = 'Charlie' WHERE id = 1;`<br>`SAVEPOINT before_change;`<br>`ROLLBACK TO before_change;`<br>`COMMIT;`   |



> `users` 테이블: 사용자 정보 저장  
> `posts` 테이블: 게시글 저장  
> `comments` 테이블: 댓글 저장 (외래 키 포함)  

### DDL(Data Definition Language)

`CREATE`
  - 데이터베이스에서 관리될 수 있는 다양한 대상을 정의
  - 예시
    - 데이터베이스 생성
      ```sql
      CREATE DATABASE blog_db;
      USE blog_db;  -- 추가! USE와 DESCRIBE? 이것도 추가로 작성하고 주석으로 설명적기
      ```
    - `users` 테이블 생성
      ```sql
      CREATE TABLE users (
        user_id INT PRIMARY KEY AUTO_INCREMENT,
        username VARCHAR(50) NOT NULL,
        email VARCHAR(100) UNIQUE NOT NULL,
        birthdate DATE,
        registration_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
      );
      ```
      
        | 필드명                | 타입           | 제약 조건 |
        | ------------------ | ------------ | ---------------------------- |
        | user\_id           | INT          | PRIMARY KEY, AUTO\_INCREMENT |
        | username           | VARCHAR(50)  | NOT NULL                     |
        | email              | VARCHAR(100) | UNIQUE, NOT NULL             |
        | birthdate          | DATE         |                              |
        | registration\_date | TIMESTAMP    | DEFAULT CURRENT\_TIMESTAMP   |

    - `posts` 테이블 생성 (외래 키 포함)
      ```sql
      CREATE TABLE posts (
        post_id INT PRIMARY KEY AUTO_INCREMENT,
        user_id INT,
        title VARCHAR(100) NOT NULL,
        content TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(user_id)
          ON UPDATE CASCADE
          ON DELETE SET NULL
      );
      ```

  

`ALTER`
- 필드와 제약 조건의 추가/수정/삭제
- 예시
  - 필드 추가
  ```sql
  ALTER TABLE users ADD COLUMN phone_number VARCHAR(20);
  ```

  - 필드 변경
  ```sql
  ALTER TABLE users CHANGE COLUMN phone_number contact VARCHAR(30);
  ```

  - 제약 조건 추가
  ```sql
  ALTER TABLE posts ADD CONSTRAINT uq_title UNIQUE (title);
  ```

`DROP/TRUNCATE`
- 테이블 및 데이터 삭제
- 예시

  - 테이블 삭제
  ```sql
  DROP TABLE comments;
  ```
  - 데이터만 삭제
  ```sql
  TRUNCATE TABLE posts;
  ```

### DML(Data Management Language)
데이터의 삽입, 수정, 삭제, 조회

`INSERT`  
- 예시
  ```sql
  -- users에 레코드 삽입
  INSERT INTO users (username, email, birthdate)
  VALUES ('Alice', 'alice@example.com', '1995-05-01');
  
  -- posts에 레코드 삽입
  INSERT INTO posts (user_id, title, content)
  VALUES (1, 'Hello World', 'This is my first post.');
  ```


`SELECT`  
- 레코드를 조회하는 명령, 테이블 내 레코드 정렬 및 필터링 가능 
- 기본 구조 : FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT

  ```sql
  SELECT 필드1, 필드2, …
  FROM 테이블_이름
  WHERE 조건식
  GROUP BY 그룹화할_필드
  HAVING 필터_조건
  ORDER BY 정렬할_필드
  LIMIT 레코드_제한
  ```
- 예시 
  - 전체 조회
  ```sql
  SELECT * FROM users;
  ```

  - 조건 조회 (WHERE)
  ```sql
  SELECT username, email FROM users WHERE birthdate < '2000-01-01';
  ```

  - LIKE 검색
  ```sql
  SELECT * FROM posts WHERE title LIKE '%Hello%'; -- 패턴 검색 가능
  ```

  - 집계 함수 + GROUP BY
  ```sql
  SELECT user_id, COUNT(*) AS post_count FROM posts GROUP BY user_id;
  ```
  - HAVING (그룹 조건)
  ```sql
  SELECT user_id, COUNT(*) AS post_count
  FROM posts
  GROUP BY user_id
  HAVING post_count > 5;
  ```

`UPDATE`
- 데이터 수정
- 예시
  ```sql
  UPDATE users
  SET email = 'new_email@example.com'
  WHERE username = 'Alice';
  ```

`DELETE`
- 데이터 삭제
- 예시
  - `posts` 테이블에서 `title 이 "Hello World"인 레코드` 삭제하기
  ```sql
  DELETE FROM posts
  WHERE title = 'Hello World';
  ```
  외래 키 동작 확인 (ON DELETE SET NULL)
  ```sql
  DELETE FROM users WHERE user_id = 1;
  ```

> `외래 키 제약 조건` - ON UPDATE, ON DELETE  
> UPDATE와 DELETE문에서의 외래 키 참조 테이블의 레코드 수정 및 삭제
>
> 제약 조건 설명  
> `CASCADE` : 참조하는 데이터도 함께 수정/삭제함  
> `SET NULL` : 참조하는 데이터를 NULL로 변경함  
> `SET DEFAULT` : 참조하는 데이터를 기본값(default)으로 변경함  
> `RESTRICT` : 수정/삭제를 허용하지 않음  
> 
> e.g.
> ```sql
> CREATE TABLE posts (
>  post_id INT PRIMARY KEY AUTO_INCREMENT,
>  user_id INT,
>  title VARCHAR(50) NOT NULL,
>  content VARCHAR(50),
>  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
>  FOREIGN KEY (user_id) REFERENCES users(user_id)
>  ON UPDATE CASCADE   -- UPDATE 시에 참조하는 테이블도 변경
>  ON DELETE SET NULL  -- DELETE 시에 참조하는 테이블에는 NULL
> );
> ```


### TCL(Transaction Control Language)
- 트랜잭션을 제어하는 데 사용되는 SQL 명령 e.g. COMMIT, ROLLBACK, SAVEPOINT
- 트랜잭션의 결과는 변경된 내용을 적용하고 종료(COMMIT) VS 변경된 내용을 적용하지 않고 종료(ROLLBACK)

`COMMIT`
```sql
BEGIN;

UPDATE accounts
SET balance = balance - 1000
WHERE name = 'A';

UPDATE accounts
SET balance = balance + 1000
WHERE name = 'B';

COMMIT; -- 두 작업이 동시에 확정

```

`ROLLBACK`

```sql
BEGIN;

UPDATE accounts
SET balance = balance - 1000
WHERE name = 'A';

-- 여기서 오류 발생! (예: B 계좌가 없음)
UPDATE accounts
SET balance = balance + 1000
WHERE name = 'B';

ROLLBACK;
```

`SAVEPOINT` : 

```sql
BEGIN;

UPDATE accounts SET balance = balance - 1000 WHERE name = 'A';
SAVEPOINT after_a; -- 롤백 포인트를 중간에 저장

UPDATE accounts SET balance = balance + 1000 WHERE name = 'B';
-- 또 다른 작업들...
ROLLBACK TO after_a;

COMMIT;

```
| 명령어           | 역할                    |
| ------------- | --------------------- |
| `COMMIT`      | 트랜잭션을 확정하고 DB에 반영     |
| `ROLLBACK`    | 트랜잭션 중단 및 변경 사항 모두 취소 |
| `SAVEPOINT`   | 롤백용 지점 설정             |
| `ROLLBACK TO` | 특정 세이브포인트까지만 롤백       |


### DCL(Data Control Language)
- 데이터베이스 사용자에게 권한을 부여하거나 회수할 때 사용하는 명령어
- 보통 관리자(DBA)가 사용하며, 보안 및 접근 제어에 필수

`GRANT` : 사용자에게 특정 객체(테이블, 뷰 등)에 대한 권한을 부여
```sql
-- user1에게 users 테이블에 대한 SELECT 권한 부여
GRANT SELECT ON users TO user1;

-- user1에게 SELECT, INSERT 권한 부여
GRANT SELECT, INSERT ON users TO user1;
```

`REVOKE` : 특정 사용자로부터 부여한 권한을 회수
```sql
-- user1에게 부여한 SELECT 권한 회수
REVOKE SELECT ON users FROM user1;

-- SELECT와 INSERT 권한 모두 회수
REVOKE SELECT, INSERT ON users FROM user1;
```

<div style="height:400px"></div>

## 면접 예상 질문 : 교재

<div style="font-family: sans-serif; line-height: 1.6;">
  <details>
    <summary>
      <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">질문</strong>
    </summary> 
  <p>
    <strong style="color: #999;">A.</strong>내용
  </p>
  </details>
</div>

## 면접 예상 질문 : 추가 질문

<div style="font-family: sans-serif; line-height: 1.6;">
  <details>
    <summary>
      <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">트랜잭션의 핵심 특징은 무엇인가요?</strong>
    </summary> 
  <p>
    <strong style="color: #999;">A.</strong>트랜잭션은 데이터베이스에서 하나의 논리적인 작업 단위로, 실행 중인 작업이 모두 성공하거나 모두 실패해야 하는 특성을 가집니다. 트랜잭션의 핵심적인 특징은 ACID, 네 가지로 정리할 수 있습니다.<br>
    첫 번째는 원자성(Atomicity)입니다. 이는 트랜잭션 내 모든 작업이 하나의 단위처럼 처리되어, 일부만 실행되는 일이 없어야 한다는 의미입니다. 예를 들어, A 계좌에서 B 계좌로 송금할 때 출금만 되고 입금이 되지 않는 상황은 발생하면 안 됩니다.<br>
    두 번째는 일관성(Consistency)입니다. 트랜잭션이 수행되기 전과 후의 데이터는 항상 정해진 제약 조건이나 규칙을 만족해야 합니다. 앞의 예시처럼 송금 후에도 전체 계좌의 총 금액은 바뀌지 않아야 합니다.
    세 번째는 격리성(Isolation)입니다. 동시에 여러 트랜잭션이 실행되더라도 각각은 서로 독립적으로 실행되는 것처럼 보이도록 보장되어야 합니다. 예를 들어, 같은 상품을 동시에 두 명이 결제할 때 데이터 충돌이 일어나지 않도록 처리되어야 합니다.<br>
    마지막은 지속성(Durability)입니다. 트랜잭션이 성공적으로 완료되면, 그 결과는 시스템에 영구적으로 반영되어야 합니다. 설령 서버가 갑자기 꺼지더라도 해당 작업은 되돌아가지 않고 유지되어야 합니다. <br>
    이 네 가지 특성은 데이터의 신뢰성과 안정성을 보장하기 위해 트랜잭션에서 반드시 충족되어야 합니다.
  </p>
  </details>
  <details>
    <summary>
      <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">데이터베이스에서 무결성 제약 조건은 어떤 것이 있는지 설명해 주세요.</strong>
    </summary> 
  <p>
    <strong style="color: #999;">A.</strong>데이터베이스에서 무결성 제약 조건은 데이터의 정확성과 일관성을 보장하기 위해 사용되는 규칙들입니다. 가장 대표적인 무결성 제약 조건은 네 가지로 나눌 수 있습니다. <br>
    먼저, 개체 무결성(Entity Integrity)은 기본키에 대한 제약입니다. 기본키는 테이블 내의 각 행을 고유하게 식별하기 위한 값이기 때문에, 반드시 NULL이 될 수 없고, 중복될 수 없습니다.<br>
    두 번째는 참조 무결성(Referential Integrity)입니다. 외래키 제약을 통해 다른 테이블을 참조할 때, 참조하려는 기본키가 실제로 존재해야 한다는 조건입니다. 예를 들어, 주문 테이블에서 고객 ID를 참조한다면, 해당 고객 ID가 고객 테이블에 반드시 존재해야 합니다.<br>
    세 번째는 도메인 무결성(Domain Integrity)으로, 각 컬럼은 미리 정해진 데이터 형식이나 범위를 따라야 합니다. 예를 들어, 나이 필드는 정수형이며, 음수가 들어갈 수 없도록 제한할 수 있습니다.<br>
    마지막은 사용자 정의 무결성(User-defined Integrity)입니다. 이는 특정 비즈니스 로직에 따라 설정하는 조건으로, 예를 들어 급여는 최소 100만 원 이상이어야 한다는 식의 규칙을 포함합니다.<br>
    이러한 무결성 제약 조건들은 데이터를 저장하고 관리할 때 발생할 수 있는 오류를 사전에 방지하고, 시스템의 신뢰성을 높이는 데 중요한 역할을 합니다.
  </p>
  </details>
  <details>
    <summary>
      <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">기본키와 슈퍼키의 차이는 무엇인가요?</strong>
    </summary> 
  <p>
    <strong style="color: #999;">A.</strong>기본키와 슈퍼키는 모두 데이터베이스에서 각 행을 고유하게 식별하기 위한 키입니다. 슈퍼키(Super Key)는 하나 이상의 속성으로 구성되어, 튜플을 유일하게 식별할 수 있는 모든 후보 키 집합입니다. 반면에 기본키(Primary Key)는 슈퍼키 중에서도 가장 최소한의 속성만으로 구성된 키를 의미합니다.
  </p>
  </details>
</div>