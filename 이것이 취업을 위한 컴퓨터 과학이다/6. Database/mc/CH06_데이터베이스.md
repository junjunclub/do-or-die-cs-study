# CH06 데이터베이스

- [1. 데이터베이스의 큰 그림](#1-데이터베이스의-큰-그림)
- [2. RDBMS의 기본](#2-rdbms의-기본)
- [3. SQL](#3-sql)
- [4. 효율적 쿼리](#4-효율적-쿼리)
- [5. 데이터베이스 설계](#5-데이터베이스-설계)
- [6. NoSQL](#6-nosqlnot-only-sql)

## 1. 데이터베이스의 큰 그림

### 데이터베이스와 DBMS

- `데이터베이스(DB)`: 여러 사람이 공유하고 사용할 수 있도록 체계적으로 저장·관리하는 데이터의 집합. (정보의 집합이라고 생각하자.)

- `DBMS(Database Management System)`: 데이터베이스를 생성, 관리, 운용하기 위한 소프트웨어.

웹 서비스의 성능과 정체성은 어떤 데이터를 어떻게 저장하느냐에 따라 달라짐.

- DBMS의 종류

| 구분           | 설명                                                 | 대표 제품                         |
| -------------- | ---------------------------------------------------- | --------------------------------- |
| **RDBMS**      | 테이블 기반의 정형화된 구조, **스키마 존재**         | MySQL, PostgreSQL, Oracle, SQLite |
| **NoSQL DBMS** | 비정형 데이터 저장 가능, **스키마 없음 또는 유연함** | MongoDB, Redis                    |

- `SQL(Structured Query Language)` : 데이터베이스를 다룰 때에 사용되는 언어 중 하나
  - `DDL(Data Definition Language)` : 데이터 정의  
    e.g. CREATE, ALTER, DROP, TRUNCATE
  - `DML(Data Manipulation Language)` : 데이터 조작
    e.g. SELECT, INSERT, UPDATE, DELETE
  - `DCL(Data Control Language)` : 데이터 제어 (작업 상태와 관련된)
    e.g. COMMIT, ROLLBACK, SAVEPOINT
  - `TCL(Transaction Control Language)` : 트랜잭션 제어  
    e.g. GRANT, REVOKE

> Q. `스키마(scheme)`란?
>
> - 테이블 구조를 정의하는 설계도
> - 필드, 데이터 타입, 제약 조건 등 정의한 것

```sql
CREATE TABLE users (
  id INT PRIMARY KEY,
  name VARCHAR(50),
  email VARCHAR(100) UNIQUE,
  created_at DATETIME DEFAULT CURRENT_TIMESTAMP
);
```

> Q. 스키마의 존재 유무가 끼치는 영향은?
> 데이터 구조의 일관성 유지, 잘못된 데이터 입력 방지, 정형화된 쿼리 작성 가능

> Q. 왜 파일보다 DBMS를 사용할까요?
>
> (1) 데이터의 일관성 및 무결성을 유지하기 위해서입니다.  
> 특정 데이터에 동시 접속할 경우 레이스 컨디션이 발생할 수 있습니다.
>
> (2) 중복되는 저장이 많을 수 있습니다.  
> 동일 정보를 반복해서 저장할 경우 공간이 낭비됩니다.
>
> (3) 연관된 데이터의 변경이 어렵습니다.
> 관련된 파일들을 일일이 찾아 수정해야 합니다.
>
> (4) 백업 및 복구가 어렵습니다.  
> 장애가 발생했을 경우 복구가 힘듭니다.

### 데이터베이스의 저장 단위

- `엔티티 (Entity)` : 저장 가능한 독립 객체, 집합이라기 보다는 하나 하나의 구성 요소 e.g. 학생, 제품, 구매자
- `엔티티 집합` : 같은 속성을 공유하는 엔티티 모음
- `속성 (Attribute)` : 엔티티의 특성 e.g. 이름, 나이, 제품번호 등
- `도메인 (Domain)` : 속성이 가질 수 있는 값의 집합 e.g. 성별이라는 속성의 도메인은 {남자, 여자}
- `레코드 (Record)` : 저장된 엔티티(DB에 기록된 값)
- `필드 (Field)` : 레코드의 속성
- `차수(degree)` : 필드의 수, 필드의 총 개수
- `카디널리티(cardinality)` : 한 필드에 대한 고유 값의 수 e.g. 성별이라는 필드의 카디널리티는 2 이다.
- `릴레이션 (Relation)` : 테이블 구조로 표현된 엔티티 집합 e.g. SQL 테이블  
  `+` NoSQL에서는 `컬렉션(collection)`이라는 단위로 표현

> 엔티티는 저장 가능한 대상, 레코드는 저장된 대상

### 트랜잭션과 ACID

- `트랜잭션 (Transaction)` : DB에서 하나의 논리적 작업 단위

  - `TPS` : 초당 트랜잭션 처리 수, 성능 지표로 활용

- `ACID` : 트랜잭션의 핵심 특징(원자성, 일관성, 격리성, 지속성)

| 속성                         | 설명                                       | 예시                               |
| ---------------------------- | ------------------------------------------ | ---------------------------------- |
| **A - 원자성 (Atomicity)**   | 모두 성공하거나 모두 실패 (All or Nothing) | 송금 중 실패 시, 출금도 롤백       |
| **C - 일관성 (Consistency)** | 트랜잭션 전후 데이터 일관된 상태 유지      | 학과 인원수 +1 일관성 유지         |
| **I - 격리성 (Isolation)**   | 동시 수행 트랜잭션 간 간섭 방지            | 같은 재고 상품 2명이 동시에 구매 X |
| **D - 지속성 (Durability)**  | 완료된 트랜잭션 결과는 영구 저장           | 전기 꺼져도 입금 내용 보존됨       |

> 쉽게 외워보기
>
> 1. 원자성(Atomicity)
>    Atomic = 더 쪼갤 수 없는
>    원자처럼 하나의 단위로 처리되는 성질이다.
>    트랜잭션은 하나의 원자처럼 하나의 트랜잭션이 다 처리되거나, 다 처리가 안 되거나!
>
> 2. 일관성(Consistency)
>    일관성 = 앞뒤가 맞고 규칙을 지킨다.
>    어떤 작업을 해도 데이터는 항상 정해진 규칙을 만족해야한다.
>    e.g. 일관성은 최종적인 결과에 관한 것인듯 => A가 50만원 출금 -> B에게 50만원 송금하면 A + B는 여전히 유지되어야한다!
>
> 3. 격리성(Isolation)
>    격리 = 따로 떨어져 있다.
>    동시에 여러 트랜잭션이 실행되더라도 서로 간섭하지 않도록 처리해야한다.
>
> 4. 지속성(Durability)
>    지속 = 오래 간다, 남아 있다.
>    트랜잭션이 성공적으로 끝났다면 그 결과는 어떠한 상황에서도 보존되어야 한다.

## 2 RDBMS의 기본

필드 타입, 키, 무결성 제약 조건, 테이블 간 관계

### 테이블의 구성: 필드와 레코드

- 용어 정리
  - `테이블(Table)`: RDBMS에서 데이터를 저장하는 기본 단위. 행(Row, Record)과 열(Column, Field)로 구성
  - `필드(Field)`: 컬럼(열), 한 속성(attribute)을 나타냄. 예: 이름, 나이
  - `레코드(Record)`: 행. 실제 데이터 한 줄(실제로 저장된 데이터)

---

- 필드 타입(Field Type) : 다양한 필드 타입이 존재하며, 테이블을 생성할 때에 각 필드에 필드 타입을 지정한다.

| 분류        | 예시                        |
| ----------- | --------------------------- |
| 숫자형      | INT, FLOAT, DOUBLE, DECIMAL |
| 문자형      | CHAR, VARCHAR, TEXT         |
| 날짜/시간형 | DATE, TIME, DATETIME        |
| 기타        | BOOLEAN, BLOB               |

```sql
CREATE TABLE Student (
  student_id INT,
  name VARCHAR(50),
  email VARCHAR(100),
  birth_date DATE
);

```

### 키(Key)

테이블의 레코드를 식별할 수 있는 하나 이상의 필드

- `후보 키(Candidate Key)` : 레코드를 식별할 수 있는 최소 필드 집합, 여러 개일 수도 있다. (기본키 + 대체키)

  - `기본 키(Primary Key)` : 후보 키 중에서 대표로 선택된 키, 테이블 당 하나만 존재하며, NULL 및 중복은 불가하다!
  - `대체 키(Alternate Key)` : 기본 키가 아닌 나머지 후보 키

- `외래 키(Foreign Key)` : 다른 테이블의 기본 키를 참조하는 필드이다. 참조 관계 형성 시에 사용

- `슈퍼 키(Super Key)` : 유일성은 만족하나 최소성은 만족하지 않는 키이다.  
   (student_id + name과 같이 레코드를 유일하게 식별할 수 있지만, 최소한의 정보만 가지고 있는 것은 아니다.)

- `복합 키(Composite Key)` : 두 개 이상의 컬럼으로 구성된 키(후보키 중에서 두 개 이상의 컬럼으로 구성된 키가 있을 수 있다.)

> **유일성과 최소성**  
> `유일성` : 특정 레코드를 유일하게 식별한다. => 유일성을 갖추었다.
>
> `최소성` : 최소한의 정보로 레코드를 식별한다. => 최소성을 갖추었다.

```sql
CREATE TABLE Student (
  student_id INT PRIMARY KEY, -- student_id는 후보 키 이면서 기본 키
  email VARCHAR(100) UNIQUE,
  phone VARCHAR(20)
);
```

```sql
CREATE TABLE Score (
  student_id INT,
  subject_code VARCHAR(10),
  year INT,
  grade CHAR(1),
  PRIMARY KEY (student_id, subject_code), -- 복합 키
  FOREIGN KEY (student_id) REFERENCES Student(student_id)
);
```

### 테이블 간 관계

외래 키를 매개로 하는 테이블 간 연관 관계

- `1:1 (일대일) 대응` : 한 레코드가 다른 테이블의 한 레코드에만 대응된다.  
   e.g. 승객은 각자 하나의 여권만 가질 수 있다.

- `1:N (일대다) 대응` : 한 레코드가 다른 테이블의 여러 레코드에 대응된다.  
   e.g. 영화 하나에 여러 사람이 댓글을 남길 수 있다.

- `N:M (다대다) 대응` : 여러 레코드가 다른 테이블의 여러 레코드에 대응된다. 일반적으로 중간 테이블을 가진다.  
   e.g. SNS에서는 여러 사람이 서로를 팔로우하고 있다.

```sql
CREATE TABLE User (
  user_id INT PRIMARY KEY,
  name VARCHAR(50)
);

CREATE TABLE Group (
  group_id INT PRIMARY KEY,
  group_name VARCHAR(50)
);

CREATE TABLE UserGroup (
  user_id INT,
  group_id INT,
  PRIMARY KEY(user_id, group_id),
  FOREIGN KEY(user_id) REFERENCES User(user_id),
  FOREIGN KEY(group_id) REFERENCES Group(group_id)
);

```

### 무결성 제약 조건

- `무결성` : 일관되며 유효한 데이터의 상태 (문제가 없는, 무결한 상태)
- `무결성 제약 조건` : 데이터베이스에 저장된 데이터의 `일관성(특정 규칙을 지키는 상태)과 유효성(=무결성)`유지하기 위해 지켜야 하는 조건

  - `도메인 제약 조건(domain constraint)`  
     테이블이 가질 수 있는 필드 타입과 범위에 대한 규칙입니다.
    각각의 필드 데이터는 원자 값을 가지며, 필드 타입을 준수해야한다.

    > `+` `원자 값(atomic value)` : 더 이상 쪼갤 수 없는 단일한 값
    >
    > e.g.  
    > ("김지영", 23, "여") => 각각의 필드 데이터는 원자
    > ["김지영, 23, 여"] => 한 필드에 들어가 있는 정보가 쪼개질 수 있음

  - `키 제약 조건(key constraint)`  
     키로 지정된 필드에 중복된 값이 존재해서는 안 된다 (중복되면 유일하게 식별할 수 없음)

  - `엔티티 무결성 제약 조건(entity integrity constraint, 기본 키 제약 조건)`  
     기본 키로 지정한 필드는 고유한 값이며, NULL이 되어서는 안 된다

  - `참조 무결성 제약 조건(referential integrity constraint, 외래 키 제약 조건)`  
     외래 키는 참조하는 테이블의 기본 키와 같은 값을 갖거나 NULL값을 가져야 한다

> 참조하는 테이블이 삭제/수정되는 경우
>
> 영화에 여러 댓글이 작성되어 있다. 댓글 테이블이 영화 테이블을 참조하고 있다.  
> 이 때에 영화가 삭제되는 경우에는 이를 참조하는 댓글 테이블은 어떻게 될까?
> ➊ 연산 제한(RESTRICT)  
> 주어진 수정 및 삭제 연산 자체를 거부한다. => 영화 삭제 불가능
> ➋ 기본값 설정(SET DEFAULT)  
> 참조하는 레코드를 미리 지정한 기본값으로 설정한다.
> ➌ NULL 값 설정(SET NULL)  
> 참조하는 레코드를 NULL로 설정한다. => 댓글에 해당하는 영화에 NULL이 들어간다.
> ➍ 연쇄 변경(CASCADE)  
> 참조하는 레코드도 함께 수정되거나 삭제한다. => 영화가 삭제되면 거기에 달린 댓글들도 함께 삭제된다.

```sql
CREATE TABLE Enrollment (
  student_id INT,
  course_id INT,
  PRIMARY KEY(student_id, course_id),
  FOREIGN KEY(student_id) REFERENCES Student(student_id) ON DELETE CASCADE
);

```

## 3 SQL

`데이터 정의 언어(DDL)`, `데이터 조작 언어(DML)`, `데이터 제어 언어(DCL)`, `트랜잭션 제어 언어(TCL)`

| 분류                                      | 설명                                | 주요 명령어                                          | 예시                                                                                                                                                                |
| ----------------------------------------- | ----------------------------------- | ---------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **DDL**<br>(Data Definition Language)     | 데이터베이스 **구조 정의**          | `CREATE`, `ALTER`, `DROP`, `TRUNCATE`, `RENAME`      | `CREATE TABLE users ( id INT PRIMARY KEY, name VARCHAR(50) );`<br>`ALTER TABLE users ADD email VARCHAR(100);`<br>`DROP TABLE users;`                                |
| **DML**<br>(Data Manipulation Language)   | 테이블 내 **데이터 조작**           | `SELECT`, `INSERT`, `UPDATE`, `DELETE`               | `SELECT * FROM users;`<br>`INSERT INTO users (id, name) VALUES (1, 'Alice');`<br>`UPDATE users SET name = 'Bob' WHERE id = 1;`<br>`DELETE FROM users WHERE id = 1;` |
| **DCL**<br>(Data Control Language)        | 사용자에 대한 **권한 제어**         | `GRANT`, `REVOKE`                                    | `GRANT SELECT ON users TO user1;`<br>`REVOKE SELECT ON users FROM user1;`                                                                                           |
| **TCL**<br>(Transaction Control Language) | 트랜잭션 처리 및 **일괄 작업 제어** | `COMMIT`, `ROLLBACK`, `SAVEPOINT`, `SET TRANSACTION` | `BEGIN;`<br>`UPDATE users SET name = 'Charlie' WHERE id = 1;`<br>`SAVEPOINT before_change;`<br>`ROLLBACK TO before_change;`<br>`COMMIT;`                            |

> `users` 테이블: 사용자 정보 저장  
> `posts` 테이블: 게시글 저장  
> `comments` 테이블: 댓글 저장 (외래 키 포함)

### DDL(Data Definition Language)

`CREATE`

- 데이터베이스에서 관리될 수 있는 다양한 대상을 정의
- 예시

  - 데이터베이스 생성
    ```sql
    CREATE DATABASE blog_db;
    USE blog_db;  -- 추가! USE와 DESCRIBE? 이것도 추가로 작성하고 주석으로 설명적기
    ```
  - `users` 테이블 생성

    ```sql
    CREATE TABLE users (
      user_id INT PRIMARY KEY AUTO_INCREMENT,
      username VARCHAR(50) NOT NULL,
      email VARCHAR(100) UNIQUE NOT NULL,
      birthdate DATE,
      registration_date TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
    ```

    | 필드명            | 타입         | 제약 조건                   |
    | ----------------- | ------------ | --------------------------- |
    | user_id           | INT          | PRIMARY KEY, AUTO_INCREMENT |
    | username          | VARCHAR(50)  | NOT NULL                    |
    | email             | VARCHAR(100) | UNIQUE, NOT NULL            |
    | birthdate         | DATE         |                             |
    | registration_date | TIMESTAMP    | DEFAULT CURRENT_TIMESTAMP   |

  - `posts` 테이블 생성 (외래 키 포함)
    ```sql
    CREATE TABLE posts (
      post_id INT PRIMARY KEY AUTO_INCREMENT,
      user_id INT,
      title VARCHAR(100) NOT NULL,
      content TEXT,
      created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
      FOREIGN KEY (user_id) REFERENCES users(user_id)
        ON UPDATE CASCADE
        ON DELETE SET NULL
    );
    ```

`ALTER`

- 필드와 제약 조건의 추가/수정/삭제
- 예시

  - 필드 추가

  ```sql
  ALTER TABLE users ADD COLUMN phone_number VARCHAR(20);
  ```

  - 필드 변경

  ```sql
  ALTER TABLE users CHANGE COLUMN phone_number contact VARCHAR(30);
  ```

  - 제약 조건 추가

  ```sql
  ALTER TABLE posts ADD CONSTRAINT uq_title UNIQUE (title);
  ```

`DROP/TRUNCATE`

- 테이블 및 데이터 삭제
- 예시

  - 테이블 삭제

  ```sql
  DROP TABLE comments;
  ```

  - 데이터만 삭제

  ```sql
  TRUNCATE TABLE posts;
  ```

### DML(Data Management Language)

데이터의 삽입, 수정, 삭제, 조회

> 쿼리 작성 순서는?
>
> ```sql
> SELECT department.name, COUNT(*)
> FROM employees
> JOIN department ON employees.dept_id = department.id
> WHERE employees.age > 30
> GROUP BY department.name
> HAVING COUNT(*) > 5
> ORDER BY COUNT(*) DESC
> LIMIT 10;
> ```
>
> 쿼리가 처리되는 순서는?  
> FROM → JOIN → ON → WHERE → GROUP BY → HAVING → SELECT → DISTINCT → ORDER BY → LIMIT

`INSERT`

- 예시

  ```sql
  -- users에 레코드 삽입
  INSERT INTO users (username, email, birthdate)
  VALUES ('Alice', 'alice@example.com', '1995-05-01');

  -- posts에 레코드 삽입
  INSERT INTO posts (user_id, title, content)
  VALUES (1, 'Hello World', 'This is my first post.');
  ```

`SELECT`

- 레코드를 조회하는 명령, 테이블 내 레코드 정렬 및 필터링 가능
- 기본 구조 : FROM → WHERE → GROUP BY → HAVING → SELECT → ORDER BY → LIMIT

  ```sql
  SELECT 필드1, 필드2, …
  FROM 테이블_이름
  WHERE 조건식
  GROUP BY 그룹화할_필드
  HAVING 필터_조건
  ORDER BY 정렬할_필드
  LIMIT 레코드_제한
  ```

- 예시

  - 전체 조회

  ```sql
  SELECT * FROM users;
  ```

  - 조건 조회 (WHERE)

  ```sql
  SELECT username, email FROM users WHERE birthdate < '2000-01-01';
  ```

  - LIKE 검색

  ```sql
  SELECT * FROM posts WHERE title LIKE '%Hello%'; -- 패턴 검색 가능
  ```

  - 집계 함수 + GROUP BY

  ```sql
  SELECT user_id, COUNT(*) AS post_count FROM posts GROUP BY user_id;
  ```

  - HAVING (그룹 조건)

  ```sql
  SELECT user_id, COUNT(*) AS post_count
  FROM posts
  GROUP BY user_id
  HAVING post_count > 5;
  ```

`UPDATE`

- 데이터 수정
- 예시
  ```sql
  UPDATE users
  SET email = 'new_email@example.com'
  WHERE username = 'Alice';
  ```

`DELETE`

- 데이터 삭제
- 예시
  - `posts` 테이블에서 `title 이 "Hello World"인 레코드` 삭제하기
  ```sql
  DELETE FROM posts
  WHERE title = 'Hello World';
  ```
  외래 키 동작 확인 (ON DELETE SET NULL)
  ```sql
  DELETE FROM users WHERE user_id = 1;
  ```

> `외래 키 제약 조건` - ON UPDATE, ON DELETE  
> UPDATE와 DELETE문에서의 외래 키 참조 테이블의 레코드 수정 및 삭제
>
> 제약 조건 설명  
> `CASCADE` : 참조하는 데이터도 함께 수정/삭제함  
> `SET NULL` : 참조하는 데이터를 NULL로 변경함  
> `SET DEFAULT` : 참조하는 데이터를 기본값(default)으로 변경함  
> `RESTRICT` : 수정/삭제를 허용하지 않음
>
> e.g.
>
> ```sql
> CREATE TABLE posts (
>  post_id INT PRIMARY KEY AUTO_INCREMENT,
>  user_id INT,
>  title VARCHAR(50) NOT NULL,
>  content VARCHAR(50),
>  created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
>  FOREIGN KEY (user_id) REFERENCES users(user_id)
>  ON UPDATE CASCADE   -- UPDATE 시에 참조하는 테이블도 변경
>  ON DELETE SET NULL  -- DELETE 시에 참조하는 테이블에는 NULL
> );
> ```

### TCL(Transaction Control Language)

- 트랜잭션을 제어하는 데 사용되는 SQL 명령 e.g. COMMIT, ROLLBACK, SAVEPOINT
- 트랜잭션의 결과는 변경된 내용을 적용하고 종료(COMMIT) VS 변경된 내용을 적용하지 않고 종료(ROLLBACK)

`COMMIT`

```sql
BEGIN;

UPDATE accounts
SET balance = balance - 1000
WHERE name = 'A';

UPDATE accounts
SET balance = balance + 1000
WHERE name = 'B';

COMMIT; -- 두 작업이 동시에 확정

```

`ROLLBACK`

```sql
BEGIN;

UPDATE accounts
SET balance = balance - 1000
WHERE name = 'A';

-- 여기서 오류 발생! (예: B 계좌가 없음)
UPDATE accounts
SET balance = balance + 1000
WHERE name = 'B';

ROLLBACK;
```

`SAVEPOINT` :

```sql
BEGIN;

UPDATE accounts SET balance = balance - 1000 WHERE name = 'A';
SAVEPOINT after_a; -- 롤백 포인트를 중간에 저장

UPDATE accounts SET balance = balance + 1000 WHERE name = 'B';
-- 또 다른 작업들...
ROLLBACK TO after_a;

COMMIT;

```

| 명령어        | 역할                                 |
| ------------- | ------------------------------------ |
| `COMMIT`      | 트랜잭션을 확정하고 DB에 반영        |
| `ROLLBACK`    | 트랜잭션 중단 및 변경 사항 모두 취소 |
| `SAVEPOINT`   | 롤백용 지점 설정                     |
| `ROLLBACK TO` | 특정 세이브포인트까지만 롤백         |

### DCL(Data Control Language)

- 데이터베이스 사용자에게 권한을 부여하거나 회수할 때 사용하는 명령어
- 보통 관리자(DBA)가 사용하며, 보안 및 접근 제어에 필수

`GRANT` : 사용자에게 특정 객체(테이블, 뷰 등)에 대한 권한을 부여

```sql
-- user1에게 users 테이블에 대한 SELECT 권한 부여
GRANT SELECT ON users TO user1;

-- user1에게 SELECT, INSERT 권한 부여
GRANT SELECT, INSERT ON users TO user1;
```

`REVOKE` : 특정 사용자로부터 부여한 권한을 회수

```sql
-- user1에게 부여한 SELECT 권한 회수
REVOKE SELECT ON users FROM user1;

-- SELECT와 INSERT 권한 모두 회수
REVOKE SELECT, INSERT ON users FROM user1;
```

<div style="height:400px"></div>

## 4. 효율적 쿼리

### 여러 테이블을 한 번에 조회하기

관계형 데이터베이스에서는 여러 테이블을 묶어서 조회하는 경우가 많다.

```sql
SELECT users.username, users.email, posts.title
  FROM users, posts
  WHERE users.user_id = post;
```

### 서브 쿼리(Subquery)와 조인(Join)

`서브 쿼리`와 `조인`은 여러 테이블에 복잡한 질의를 할 때 사용되는 기법

#### 서브 쿼리(Subquery)

- `다른 SQL문 안에 포함된 SQL문`괄호 `()`로 감싸서 사용
- 외부 쿼리가 실행되기 전에 서브 쿼리가 먼저 실행되어 반환된 결과가 외부 쿼리의 조건으로 사용된다.
- <u>필드명보다 값이 중요! 비교 가능한 값이어야한다.</u> 같은 이름을 사용하는 이유는 직관적이고 명확한 관계를 나타내기 위해서일 뿐이다.

```sql
DELETE FROM posts
WHERE user_id = ( -- 서브 쿼리의 결과가 조건값으로 사용된다.
  SELECT user_id
  FROM users
  WHERE email = 'kim@example.com'
);
```

#### 조인(Join)

- `두 개 이상의 테이블을 하나로 합치는 것`
- 여러 테이블에 흩어져 있는 관련 데이터를 결합하여 하나의 결과 테이블로 만든다. <u>서브 쿼리보다 성능 면에서 더 효율적인</u> 경우가 많다.

`SELECT 테이블 1 {INNER / LEFT / RIGHT / FULL} JOIN 테이블 2`

`INNER JOIN` : 두 테이블에서 <u>조인 조건을 모두 만족하는 행만 선택한다.</u> (교집합)

```sql
SELECT users.user_id, users.email, posts.post_id, posts.title
FROM users
INNER JOIN posts ON users.user_id = posts.user_id;
```

`OUTER JOIN` : 조인 조건을 만족하지 않더라도 한쪽 테이블의 모든 행을 포함한다. 대응되지 않는 부분은 NULL로 채워진다.

- `LEFT OUTER JOIN` : 왼쪽의 테이블(테이블 1)을 기준으로 오른쪽의 테이블(테이블 2)의 레코드를 합치되, 대응되는 게 없다면 NULL로 간주.

- `RIGHT OUTER JOIN` : 오른쪽의 테이블(테이블 2)을 기준으로 왼쪽의 테이블(테이블 1)의 레코드를 합치되, 대응되는 게 없다면 NULL로 간주.

- `FULL OUTER JOIN` : 두 테이블의 모든 레코드를 선택하되, 대응되지 않는 레코드를 모두 NULL로 표기

<div style="display: grid; gap: 10px; padding: 10px; grid-template-columns: repeat(4, 1fr);">
  <div>
    <p>INNER JOIN</p>
    <img src="./assets/innerjoin.PNG" alt="이미지 1" style="">
  </div>
  <div>
    <p>LEFT JOIN</p>
    <img src="./assets/leftjoin.PNG" alt="이미지 2" style="">
  </div>
  <div>
    <p>RIGHT JOIN</p>
    <img src="./assets/rightjoin.PNG" alt="이미지 3" style="">
  </div>
  <div>
    <p>FULL JOIN</p>
    <img src="./assets/fulljoin.PNG" alt="이미지 4" style="">
  </div>
</div>

### 뷰(View)

- `SELECT`문의 실행 결과로 만들어지는 '가상의 테이블'

```sql
-- myview라는 걸로 가상의 테이블을 생성하여 재사용
CREATE VIEW myview AS
 SELECT users.username, users.email, posts.title
 FROM users, posts
 WHERE users.user_id = posts.user
```

- 재사용성 및 보안 강화

- `주의점`: 뷰는 주로 `조회(SELECT)` 목적`으로 사용된다. 여러 테이블을 포함하는 뷰는 데이터의 삽입/수정/삭제가 불가능하거나 제약이 따른다.

### 인덱스(Index)

- `테이블의 검색 속도를 높이기 위해 특정 필드에 생성하는 자료구조`이다.

- `원리`: 인덱스는 특정 필드의 데이터와 해당 레코드의 위치를 연결하여 검색 시간을 줄인다. 인덱스가 없으면 원하는 데이터를 찾기 위해 모든 레코드를 확인해야 한다.

- `자료구조`: 일반적으로 `B-Tree` 또는 `B+Tree`로 구현된다.

- `인덱스의 종류 (MySQL 기준)`:
  - `클러스터형 인덱스(clustered index)`: 테이블당 하나만 가질 수 있으며, `기본 키(PRIMARY KEY)`에 의해 자동으로 생성된다. 데이터 자체가 정렬된 상태로 저장된다.
  - `세컨더리 인덱스(secondary index)`: 클러스터형 인덱스 외의 모든 인덱스를 의미한다. 테이블당 여러 개를 만들 수 있다.
- `장단점`:

  - `장점`: `SELECT`문의 검색 속도를 획기적으로 향상시킨다.
  - `단점`: `INSERT`, `UPDATE`, `DELETE` 시 인덱스도 함께 갱신해야 하므로 오버헤드가 발생한다. 인덱스 저장에 추가 공간이 필요하다.

- `활용`: 데이터 조회(`SELECT`)가 빈번하고, 변경(`INSERT`, `UPDATE`, `DELETE`)이 적은 테이블에 효과적이다. 특히 `WHERE`절이나 `ORDER BY`절에 자주 사용되는 필드에 생성하는 것이 좋다.

## 5. 데이터베이스 설계

### ER 다이어그램 (ERD)

- 엔티티(Entity)와 엔티티 간의 관계(Relationship)를 시각적으로 표현한 그림

- `용도`: 데이터베이스의 구조를 명확히 하여 `유지보수`를 용이하게 하고, 개발자 간 `소통`을 돕는다.

- `표기법`:

  - `IE 표기법(Information Engineering notation)`: '새 발(crow's feet)' 모양의 표기법으로, 관계형 데이터베이스(RDBMS) 모델링에 직관적이다.

- `관계`:
  - `식별 관계(identifying replationship)`: 부모 테이블의 기본 키가 자식 테이블의 `기본 키 겸 외래 키`가 된다.  
    e.g. Users와 UserDetails
  - `비식별 관계(non-identifying replationship)`: 부모 테이블의 기본 키가 자식 테이블의 `일반 외래 키`가 된다.  
    e.g. Users 와 Orders

---

### 정규화(Normalization)

- `테이블의 필드 구성을 논리적으로 설계하여 데이터의 중복을 제거하고, 이상 현상을 방지하는 과정`이다.

- `이상 현상(anomaly)`: 잘못된 설계로 인해 데이터가 삽입, 수정, 삭제될 때 발생하는 부작용

  - `삽입 이상`: 새 데이터를 추가할 때 불필요한 정보도 함께 입력
  - `갱신 이상`: 중복된 데이터 중 일부만 수정되어 불일치 발생
  - `삭제 이상`: 특정 데이터를 삭제할 때, 필요한 정보까지 함께 삭제

- `정규형의 단계`:

  - `제1 정규형(1NF)`: 모든 필드가 `원자값(atomic value)`을 가져야 한다.
  - `제2 정규형(2NF)`: 1NF를 만족하고, 기본 키가 아닌 모든 필드가 `기본 키 전체에 종속`되어야 한다 (부분 함수 종속 제거)  
    보통 기본 키가 2개 이상의 필드로 구성되어 있을 때 고려된다.  
    e.g. 학생들의 성적을 관리하는 테이블  
    기본키 : student_id + subject_id => 여기에 만약에 학생 이름이 있다면, 이는 student_id와 연관이 있으므로 제 2 정규형 만족 X

  - `제3 정규형(3NF)`: 2NF를 만족하고, 기본 키가 아닌 필드들끼리 서로 종속되지 않아야 한다 (이행 함수 종속 제거).  
    e.g. 필드에 (학번, 학과, 학과 사무실 위치)가 있다면  
    학번으로 학과를 알 수 있고, 학과로 학과 사무실 위치를 알 수 있으므로 제 3정규형 만족 X

  - `보이스/코드 정규형(BCNF)`: 3NF보다 더 엄격한 정규형으로, 모든 결정자(다른 속성들을 유일하게 결정하는 속성)가 후보 키여야 한다.
    > 책에 나온 예시를 살펴보자.  
    > (학번, 과목 번호, 담당교수)가 있다고 할 때,  
    > (학번, 과목 번호)는 후보키이다.  
    > 그런데, 담당교수는 (과목 번호)에 의존한다. = 과목 번호는 결정자!  
    > (과목 번호) 후보키가 아니므로, BCNF를 만족하지 않는다.
    >
    > 후보 키(Candidate Key): 어떤 테이블에서 모든 속성(Attribute)을 유일하게 식별할 수 있는 최소한의 속성 집합.  
    > 결정자(Determinant): 다른 속성들을 유일하게 결정하는 속성.

## 6. NoSQL(Not Only SQL)

테이블 이외의 다양한 형태로 저장할 수 있다.

### 다양한 NoSQL 유형

1. `키-값 데이터베이스(Key-Value Database)`

   - `특징`: 가장 단순한 형태로, 데이터를 `키(key)`와 `값(value)`의 쌍으로 저장한다.
   - `예시`: `Redis`, `Memcached` = 인 메모리 데이터베이스
   - `활용`: 캐시, 세션 저장 등 가벼운 정보 저장에 주로 사용된다.  
     `인 메모리 데이터베이스(in-memory database)` : 보조기억장치가 아닌 메모리에 저장

2. `도큐먼트 데이터베이스(Document Database)`

   - `특징`: 데이터를 `도큐먼트(document)` 단위로 저장하고 관리  
     `도큐먼트` : `JSON`이나 `XML` 같은 NoSQL의 단위
   - `예시`: `MongoDB`
   - `구조`: 여러 도큐먼트가 모여 `컬렉션(collection)`을 이루고, 컬렉션이 모여 데이터베이스를 이룬다. 유연한 스키마가 특징이다.  
     => label == document / table == collection

3. `그래프 데이터베이스(Graph Database)`

   - `특징`: 데이터를 `그래프의 노드` 형태로 저장하며, 데이터 간의 연결 관계를 표현하는 데 용이하다.
   - `예시`: `neo4j`
   - `활용`: SNS 친구 관계, 추천 시스템, 교통망 등 관계성이 중요한 데이터를 다룰 때 사용된다.

4. `칼럼 패밀리 데이터베이스(Column Family Database)`
   - `특징`: `RDBMS`와 유사하게 행과 열의 개념이 있지만, 열을 동적으로 추가할 수 있어 스키마가 유연하다.
   - `예시`: `Cassandra`, `HBase`

### RDBMS vs NoSQL: NoSQL의 특징

| 특징          | RDBMS                                 | NoSQL                                             |
| :------------ | :------------------------------------ | :------------------------------------------------ |
| `데이터 모델` | 정형화된 테이블 (고정 스키마)         | 비정형, 유연한 스키마                             |
| `확장성`      | 수직적 확장(Scale-up)                 | 수평적 확장(Scale-out) 용이                       |
| `성능`        | 데이터 무결성 중시, 트랜잭션 오버헤드 | ACID를 엄격히 준수하지 않아 고성능                |
| `용도`        | 데이터의 무결성과 일관성이 중요할 때  | 대규모 데이터 처리, 분산 환경, 유연성이 중요할 때 |

> `테이블 분할 방식` : 수직적 분할과 수평적 분할
>
> 데이터베이스 분할은 테이블의 규모가 커져 성능이 저하될 때, 테이블을 물리적으로 나누어 저장하는 기술이다.
>
> `수직적 분할(Vertical Partitioning)`: 테이블의 `열(column)`을 기준으로 분할한다. 자주 접근하지 않거나 크기가 큰 열을 별도의 테이블로 분리할 때 사용된다.
>
> `수평적 분할(Horizontal Partitioning)`: 테이블의 `행(row)`을 기준으로 분할한다. '파티셔닝'이라고 하면 보통 이 방식을 의미한다.
>
> - `방법`: 범위 분할(`Range`), 목록 분할(`List`), 해시 분할(`Hash`), 키 분할(`Key`) 등이 있다.
>
> `샤딩(sharding)`  
> `수평적 분할의 특별한 형태`로, 분할된 테이블(샤드)을 `서로 다른 데이터베이스 서버에 분산하여 저장`하는 기술  
> => 특정 서버에 부하가 집중되는 현상을 방지하고, 전체적인 성능과 가용성을 높일 수 있다.  
> e.g. 쇼핑 내역이 너무 많을 경우 사용자ID 또는 시간 기반으로 샤딩한다.
>
> **Q. 그럼 만약에 여러 서버를 동시에 조회해야 하는 경우에는?**
> 서버가 각 샤드에 동시에 쿼리 요청을 보내어 결과를 합친 후 클라이언트에게 반환
> 샤딩 미들웨어가 분산 쿼리 자동 처리 => 서버가 직접 요청을 보내서 데이터를 받아오는 건 위험성이 있어서 일반적이지 않다. (API 서버나 미들웨어가 여러 샤드에 병렬 요청을 해서 처리한다.)

> `아카이브(Archive)`  
> 오래되었지만 보존이 필요한 데이터를 따로 저장하는 것  
> 주로 조회는 가끔 하지만, 삭제하거나 잃어버리면 안 되는 데이터를 말함

## 면접 예상 질문

### 면접 예상 질문 : 교재

<div style="font-family: sans-serif; line-height: 1.6;">
  <details>
    <summary>
      <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">질문</strong>
    </summary> 
  <p>
    <strong style="color: #999;">A.</strong>내용
  </p>
  </details>
</div>

### 면접 예상 질문 : 추가 질문

<div style="font-family: sans-serif; line-height: 1.6;">
  <details>
    <summary>
      <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">트랜잭션의 핵심 특징은 무엇인가요?</strong>
    </summary> 
  <p>
    <strong style="color: #999;">A.</strong>트랜잭션은 데이터베이스에서 하나의 논리적인 작업 단위로, 실행 중인 작업이 모두 성공하거나 모두 실패해야 하는 특성을 가집니다. 트랜잭션의 핵심적인 특징은 ACID, 네 가지로 정리할 수 있습니다.<br>
    첫 번째는 원자성(Atomicity)입니다. 이는 트랜잭션 내 모든 작업이 하나의 단위처럼 처리되어, 일부만 실행되는 일이 없어야 한다는 의미입니다. 예를 들어, A 계좌에서 B 계좌로 송금할 때 출금만 되고 입금이 되지 않는 상황은 발생하면 안 됩니다.<br>
    두 번째는 일관성(Consistency)입니다. 트랜잭션이 수행되기 전과 후의 데이터는 항상 정해진 제약 조건이나 규칙을 만족해야 합니다. 앞의 예시처럼 송금 후에도 전체 계좌의 총 금액은 바뀌지 않아야 합니다.
    세 번째는 격리성(Isolation)입니다. 동시에 여러 트랜잭션이 실행되더라도 각각은 서로 독립적으로 실행되는 것처럼 보이도록 보장되어야 합니다. 예를 들어, 같은 상품을 동시에 두 명이 결제할 때 데이터 충돌이 일어나지 않도록 처리되어야 합니다.<br>
    마지막은 지속성(Durability)입니다. 트랜잭션이 성공적으로 완료되면, 그 결과는 시스템에 영구적으로 반영되어야 합니다. 설령 서버가 갑자기 꺼지더라도 해당 작업은 되돌아가지 않고 유지되어야 합니다. <br>
    이 네 가지 특성은 데이터의 신뢰성과 안정성을 보장하기 위해 트랜잭션에서 반드시 충족되어야 합니다.
  </p>
  </details>
  <details>
    <summary>
      <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">데이터베이스에서 무결성 제약 조건은 어떤 것이 있는지 설명해 주세요.</strong>
    </summary> 
  <p>
    <strong style="color: #999;">A.</strong>데이터베이스에서 무결성 제약 조건은 데이터의 정확성과 일관성을 보장하기 위해 사용되는 규칙들입니다. 가장 대표적인 무결성 제약 조건은 네 가지로 나눌 수 있습니다. <br>
    먼저, 개체 무결성(Entity Integrity)은 기본키에 대한 제약입니다. 기본키는 테이블 내의 각 행을 고유하게 식별하기 위한 값이기 때문에, 반드시 NULL이 될 수 없고, 중복될 수 없습니다.<br>
    두 번째는 참조 무결성(Referential Integrity)입니다. 외래키 제약을 통해 다른 테이블을 참조할 때, 참조하려는 기본키가 실제로 존재해야 한다는 조건입니다. 예를 들어, 주문 테이블에서 고객 ID를 참조한다면, 해당 고객 ID가 고객 테이블에 반드시 존재해야 합니다.<br>
    세 번째는 도메인 무결성(Domain Integrity)으로, 각 컬럼은 미리 정해진 데이터 형식이나 범위를 따라야 합니다. 예를 들어, 나이 필드는 정수형이며, 음수가 들어갈 수 없도록 제한할 수 있습니다.<br>
    마지막은 사용자 정의 무결성(User-defined Integrity)입니다. 이는 특정 비즈니스 로직에 따라 설정하는 조건으로, 예를 들어 급여는 최소 100만 원 이상이어야 한다는 식의 규칙을 포함합니다.<br>
    이러한 무결성 제약 조건들은 데이터를 저장하고 관리할 때 발생할 수 있는 오류를 사전에 방지하고, 시스템의 신뢰성을 높이는 데 중요한 역할을 합니다.
  </p>
  </details>
  <details>
    <summary>
      <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">기본키와 슈퍼키의 차이는 무엇인가요?</strong>
    </summary> 
  <p>
    <strong style="color: #999;">A.</strong>기본키와 슈퍼키는 모두 데이터베이스에서 각 행을 고유하게 식별하기 위한 키입니다. 슈퍼키(Super Key)는 하나 이상의 속성으로 구성되어, 튜플을 유일하게 식별할 수 있는 모든 후보 키 집합입니다. 반면에 기본키(Primary Key)는 슈퍼키 중에서도 가장 최소한의 속성만으로 구성된 키를 의미합니다.
  </p>
  </details>
</div>

<div style="height:20px"></div>

<div>
  <details>
    <summary>
      <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">인덱스(Index)는 무엇이며, 어떤 원리로 동작하나요? 인덱스를 무분별하게 사용하면 어떤 문제가 발생할 수 있나요?</strong>
    </summary> 
  <p>
    <strong style="color: #999;">A.</strong>인덱스는 테이블의 특정 필드에 생성하는 자료구조로, 데이터 검색 속도를 높이는 데 사용합니다. 일반적으로 B-Tree나 B+Tree 같은 자료구조로 구현됩니다. 원하는 데이터를 찾기 위해 모든 레코드를 순차적으로 스캔하는 대신, 인덱스를 이용해 빠르게 원하는 위치로 이동합니다. 하지만 인덱스를 많이 생성하면 데이터 삽입, 수정, 삭제 시 인덱스도 함께 갱신해야 하는 오버헤드가 발생하며, 추가적인 저장 공간이 필요하다는 단점이 있습니다.
  </p>
  <p></p>
  </details>
  <details>
    <summary>
      <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">SELECT문에서 WHERE절과 HAVING절의 차이점은 무엇인가요?</strong>
    </summary> 
  <p>
    <strong style="color: #999;">A.</strong>WHERE절은 개별 레코드에 대한 조건을 필터링할 때 사용하고, HAVING절은 GROUP BY를 통해 그룹화된 결과에 조건을 필터링할 때 사용합니다. 예를 들어, WHERE는 '나이가 30세 미만인 사용자'를 찾을 때 사용하고, HAVING은 '게시글 수가 5개 이상인 사용자 그룹'을 찾을 때 사용합니다.
  </p>
  </details>
  <details>
    <summary>
      <strong style="color: #007B8F;">Q.</strong> <strong style="font-size: 1.05em;">JOIN과 Subquery는 어떤 경우에 사용하며, 둘의 성능 차이는 왜 발생하나요?</strong>
    </summary> 
  <p>
    <strong style="color: #999;">A.</strong>JOIN은 여러 테이블을 하나의 결과 테이블로 합쳐서 데이터를 조회하는 방식이고, Subquery는 다른 쿼리 안에 포함된 쿼리로, 그 결과를 외부 쿼리의 조건으로 사용합니다. JOIN이 일반적으로 더 효율적인 이유는, 데이터베이스가 단일 쿼리로 전체 작업을 최적화할 수 있기 때문입니다. 반면, Subquery는 내부 쿼리 결과가 임시로 저장되는 경우가 많아 성능 저하를 초래할 수 있습니다. 그래서 복잡한 쿼리에서는 JOIN을 사용하는 것이 더 좋습니다.
  </p>
  </details>
</div>
