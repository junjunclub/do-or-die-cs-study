# CH06. 데이터베이스

## 📌 핵심 개념 요약

- 데이터베이스의 큰 그림 (엔티티, 속성, 레코드, 필드, 스키마, 트랜잭션)
- RDBMS의 기본(필드 타입, 키, 테이블 간의 관계, 무결성 제약 조건)
- SQL(DDL, DCL, DML, TCL)

## 💡 면접 예상 질문
- 

## ❓스터디에서 논의하고 싶은 질문
- 

## 🔗 참고 자료
- **[책]** 이것이 취업을 위한 컴퓨터 과학이다 with CS 기술 면접

# 1. 데이터베이스의 큰 그림

## 데이터베이스와 DBMS

- **데이터베이스(Database)**
    - 여러 사용자가 공유·활용하기 위해 체계적으로 관리되는 데이터 집합.
    
    → 웹사이트의 학생 정보, 쇼핑몰의 결제 정보처럼 기능을 수행하는 데 꼭 필요한 데이터의 모음.
    
- **DBMS(Database Management System)**: 데이터베이스를 관리하기 위한 프로그램.
    
    → 대표 예: MySQL, PostgreSQL, Oracle, MongoDB, Redis 등.
    
    1. **RDBMS (Relational DBMS, 관계형)**
        - MySQL, Oracle, PostgreSQL, SQLite, MariaDB, MS SQL Server
        - 표(테이블) 기반, SQL 사용
    2. **NoSQL DBMS**
        - MongoDB, Redis
        - 유연한 구조, 대규모 데이터/확장성 유리

→ 현재 가장 널리 쓰이는 것은 **RDBMS**, 특히 **MySQL** 중심으로 학습 권장.

---

### 서버로서의 DBMS

- DBMS도 하나의 응용 프로그램이지만, 다른 프로그램(클라이언트)이 데이터를 요청하는 **서버 역할**을 수행.
- 클라이언트-서버 간 동작(TCP 연결)과 유사 = DBMS에 쿼리(SQL) 요청/응답.
- **SQL(Structured Query Language)**: RDBMS용 대표 언어.
    - **DDL** (CREATE, ALTER, DROP, TRUNCATE) → 데이터 정의
    - **DML** (SELECT, INSERT, UPDATE, DELETE) → 데이터 조작
    - **DCL** (COMMIT, ROLLBACK, SAVEPOINT) → 데이터 제어
    - **TCL** (GRANT, REVOKE) → 트랜잭션 제어

---

### 파일 대신 DBMS를 쓰는 이유가 무엇일까? (파일 관리의 한계)

> 암기가 필요한 내용은 아니니 그냥 가볍게 이해해보자
> 
1. **데이터 무결성/일관성 보장 어려움**
    - 여러 사용자가 동시에 접근하면 오류·불일치 발생 가능 (데이터 일관성 훼손)
    - 일일이 동기화 도구를 사용하는 것도 번거로운 일
    - 파일에 명시된 데이터에 결함이 없음을(무결함을) 일일이 검사하기도 힘듦
2. **중복 저장 증가**
    - 같은 정보가 여러 파일에 반복 저장됨 → 비효율.
3. **데이터 변경 어려움**
    - 연관된 데이터를 일일이 수정해야 함.
4. **정교한 검색 불가능**
    - 파일 검색은 단순 문자열 수준. 복잡한 조건 검색 힘듦.
5. **백업/복구 미비**
    - 파일만으로는 안정적 복구 체계 부족.

→ 따라서, **많은 데이터를 여러 사용자에게 제공하는 서비스에서는 DBMS가 훨씬 효율적**임.

## 데이터베이스의 저장 단위

### (1) 엔티티(Entity)와 속성(Attribute)

- **엔티티**: 독립적으로 존재할 수 있는 객체. 예: ‘김한빛’, ‘혼공 노트북’
- **속성**: 엔티티의 특징. 예: 이름, 나이, 제품 번호
- **엔티티 집합**: 같은 속성을 공유하는 엔티티들의 집합. 예: 구매자, 제품
    - RDBMS에서 표현되는 이차원 테이블 형태의 엔티티 집합은 릴레이션
    - NoSQL DBMS의 일종인 MongoDB에서 엔티티 집합은 컬렉션
- **도메인(Domain)**: 속성이 가질 수 있는 값의 범위. 예: 구매자 성별 속성 → {남자, 여자}

![image.png](attachment:71e5959a-e610-4e80-a97f-0f934313fc28:image.png)

### (2) 레코드(Record)와 필드(Field)

- **레코드**: 데이터베이스에 저장된 엔티티.
- **필드**: 레코드의 속성에 해당하는 데이터 항목.
- **RDBMS**: 레코드 → 행(row), 필드 → 열(column)
- **NoSQL(MongoDB)**: 레코드 → 도큐먼트(document), 필드 → JSON 키
- **차수(degree)**: 필드의 수
- **카디날리티(cardinality)**: 필드에 대한 고유 값의 수

### (3) 스키마(Schema)

> RDBMS와 NoSQL을 구분하는 주요 기준 중 하나
> 
- **스키마**: 레코드 구조와 제약 조건을 정의한 것 (레코드가 지켜야할 틀)
- **RDBMS**: 명확한 스키마 필요 → 정형화된 데이터 저장
- **NoSQL**: 스키마리스 → 자유로운 형태의 데이터 저장
    
    ```python
    {
    	"name": "hanbit",
    	"age": 30,
    	"email": "hanbit@example.com"
    }
    
    {
    	"name": "hanbit",
    	"age": 30,
    	"email": "media@example.com",
    	"address": {
    		"street": "123 Main St", "city": "Somewhere", "zipcode": "12345"
    	}
    }
    ```
    

---

## 트랜잭션(Transaction)과 ACID

### (1) 트랜잭션

- 데이터베이스와의 **논리적 상호작용 단위**
- 여러 쿼리로 구성될 수 있음. 예: A → B 5,000원 이체
    - A 계좌 잔액 감소
    - B 계좌 잔액 증가
- 초당 처리 트랜잭션 수 → TPS(Transactions Per Second)

### (2) 트랜잭션의 성질 (ACID)

> 여러 사용자/프로그램이 동시다발적으로 사용할 때 안전한 트랜잭션을 보장하는 성질
> 
1. **원자성(Atomicity)**
    - 트랜잭션의 모든 작업이 **모두 성공하거나 모두 실패**
    - ‘All or Nothing’
    - 반드시 커밋되거나 롤백되는 성질
        - 커밋(commit): 성공적으로 완료 → 영구 반영
        - 롤백(rollback): 취소 → 이전 상태로 되돌림
2. **일관성(Consistency)**
    - 트랜잭션 전후로 데이터베이스가 **규칙을 지킨 상태** 유지
    - 예: 학번 존재, 나이 ≥ 20, 이름 존재
3. **격리성(Isolation)**
    - 동시에 수행되는 트랜잭션이 **서로 간섭(레이스 컨디션)하지 않도록 보장**
    - 예: 재고가 하나인 상품을 동시에 구매할 때 문제 방지
4. **지속성(Durability)**
    - 완료된 트랜잭션 결과가 **영구적으로 저장**됨
    - 시스템 장애에도 데이터 손실 없음

![image.png](attachment:2ad93020-a27c-4e80-83b0-ef26826276c4:image.png)

---

# 2. RDBMS의 기본

---

## 테이블의 구성: 필드와 레코드

### **필드 타입(Field Type)**

- 데이터 유형을 지정하며, MySQL 기준 대표적 분류:
    - 숫자형: `TINYINT`, `SMALLINT`, `INT`, `BIGINT`, `FLOAT`, `DOUBLE`, `DECIMAL`
    - 문자형: `CHAR`, `VARCHAR`, `TEXT`, `BLOB`
    - 날짜/시간형: `DATE`, `TIME`, `DATETIME`, `TIMESTAMP`
    - 기타: `ENUM`, `GEOMETRY`, `XML`, `JSON`
    
    ![image.png](attachment:e0447d71-72ba-4c43-b294-6f11edf0cb56:image.png)
    

### 키

- 테이블 내 레코드를 식별하거나 테이블 간 참조에 사용.
- **주요 키 개념**:
    - **후보 키(Candidate Key)**
        - 레코드를 유일하게 식별할 수 있는 최소한의 필드 집합.
        - 유일성과 최소성을 모두 만족하는 키
        
        ![image.png](attachment:fc99b938-721c-4dc5-8ed1-73598abb8ba5:image.png)
        
        - 학번, 이메일, 전화번호 각각이 후보 키가 될 수 있음 (테이블 내에 하나이상 존재)
    - **복합 키(Composite Key)**
        - 두 개 이상의 필드로 구성된 후보 키.
        
        ![image.png](attachment:43eabcbf-71f9-4df1-8b6e-a0197df81c93:image.png)
        
        - {학번, 과목 코드}
    - **슈퍼 키 (Super Key)**
        - ‘필드의 최소 집합’이 아닌, 레코드를 식별하기 위한 ‘필드의 집합’
        - 유일성만 만족하고 최소성은 만족하지 않는다.
    
    ---
    
    - **기본 키(Primary Key), `PK`**
        - 후보 키 중 대표로 선택된 키, 테이블당 하나만 존재
        - 유일성과 최소성을 모두 만족
        - `NULL` 불가, 중복 불가.
    - **대체 키(Alternate Key)**
        - 기본 키로 선택되지 않은 나머지 후보 키.
    - **외래 키(Foreign Key), `FK`**
        - 다른 테이블의 기본 키를 참조하는 필드
        - 테이블 간 관계 형성.

---

## 테이블 간 관계

- **일대일(1:1)**: 한 레코드가 다른 테이블의 한 레코드와 대응.
    - 예: 승객 테이블 ↔ 여권 테이블
- **일대다(1:N)**: 한 레코드가 다른 테이블의 여러 레코드와 대응.
    - 예: 고객 테이블 ↔ 주문 테이블
- **다대다(N:M)**: 여러 레코드가 서로 여러 레코드와 대응, 보통 중간 테이블 사용.
    - 예: 사용자 테이블 ↔ 그룹 테이블 (중간 테이블: 사용자그룹)

---

## 무결성 제약 조건(Integrity Constraint)

> 데이터의 **일관성**과 **유효성**을 보장하는 규칙.
> 
1. **도메인 제약(Domain Constraint)**: 필드 타입과 값의 범위를 준수, 원자 값(Atomic Value) 유지.
2. **키 제약(Key Constraint)**: 키 필드에는 중복 값이 없어야 함.
3. **엔티티 무결성(Entity Integrity)**: 기본 키는 `NULL`이 될 수 없고, 유일해야 함.
4. **참조 무결성(Referential Integrity)**: 외래 키는 참조하는 기본 키 값과 같거나 `NULL`이어야 함.
    - 참조 대상 레코드 변경/삭제 시 RDBMS 동작:
        1. **Restrict**: 연산 거부
        2. **Set Default**: 기본값으로 설정
        3. **Set Null**: `NULL`로 설정
        4. **Cascade**: 연쇄 변경/삭제

# 3. SQL

## 데이터 정의 언어(DDL)

> DDL은 데이터베이스와 **데이터베이스 객체**를 생성, 수정, 삭제하는 SQL 명령어입니다.
> 

| 명령어 | 기능 |
| --- | --- |
| `CREATE` | 데이터베이스, 테이블, 뷰, 인덱스, 사용자 등을 생성 |
| `ALTER` | 기존 테이블/뷰/인덱스 구조를 수정 (컬럼 추가/삭제/제약 조건 변경) |
| `DROP` | 데이터베이스, 테이블, 뷰, 인덱스 삭제 |
| `TRUNCATE` | 테이블 구조는 유지하고 모든 레코드 삭제 |

### CREATE

```sql
CREATE TABLE posts (
    post_id INT PRIMARY KEY AUTO_INCREMENT, -- 필드_이름 필드_타입
    user_id INT,
    title VARCHAR(50) NOT NULL,
    content VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

- 필드 제약 조건
    - `PRIMARY KEY` → 고유 식별자
    - `UNIQUE` → 중복 불가
    - `AUTO_INCREMENT` → 자동 증가
    - `NOT NULL` → NULL 불가
    - `DEFAULT` → 기본값 지정
- 외래 키 참조 예제
    
    ```sql
    CREATE TABLE posts (
        post_id INT PRIMARY KEY AUTO_INCREMENT,
        user_id INT,
        title VARCHAR(50) NOT NULL,
        content VARCHAR(50),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(user_id)
    );
    ```
    
    외래 키(`FOREIGN KEY`)를 통해 참조 무결성 유지
    

### ALTER

```sql

-- 새로운 필드 추가
-- ALTER TABLE 테이블_이름 ADD COLUMN 필드_이름 필드_타입 [제약 조건]
ALTER TABLE posts ADD COLUMN new_field VARCHAR(50) NOT NULL;

-- 기존 필드 수정
-- ALTER TABLE 테이블_이름 CHANGE COLUMN 기존_필드_이름 새_필드_이름 필드_타입 [제약 조건]
ALTER TABLE posts CHANGE COLUMN new_field old_field VARCHAR(30) NOT NULL;

-- 기존 필드 삭제
-- ALTER TABLE 테이블_이름 DROP COLUMN 필드_이름 
ALTER TABLE posts DROP COLUMN old_field;

-- 외래 키 제약 조건 추가
-- ALTER TABLE 테이블_이름 [ADD CONSTRAINT 제약_조건_이름]
	-- ADD FOREIGN KEY (필드_이름) REFERENCES 참조_테이블_이름(참조_필드) 
	ALTER TABLE posts ADD FOREIGN KEY (user_id) REFERENCES users(user_id);

-- UNIQUE 제약 조건 추가
-- ALTER TABLE 테이블_이름 [ADD CONSTRAINT 제약_조건_이름] UNIQUE (필드_이름) 
ALTER TABLE posts ADD UNIQUE (title);

-- NOT NULL 제약 조건 추가
-- ALTER TABLE 테이블_이름 MODIFY 필드_이름 필드_타입 NOT NULL 
ALTER TABLE users MODIFY email VARCHAR(100) NOT NULL;

-- 기본 키 설정(PRIMARY KEY로 사용 중인 필드가 없을 경우
-- ALTER TABLE 테이블_이름 ADD PRIMARY KEY (필드_이름) 
ALTER TABLE posts ADD PRIMARY KEY (post_id);

```

### DROP

```sql
DROP DATABASE 데이터베이스_이름; 
DROP TABLE 테이블_이름;
```

### TRUNCATE

```sql
TRUNCATE TABLE 테이블_이름;
```

## 데이터 조작 언어(DML)

> DML은 테이블의 **데이터를 조회, 삽입, 수정, 삭제**하는 명령어입니다.
> 

| 명령어 | 기능 |
| --- | --- |
| `SELECT` | 레코드 조회 |
| `INSERT` | 레코드 삽입 |
| `UPDATE` | 레코드 수정 |
| `DELETE` | 레코드 삭제 |

**INSERT 예제**

```sql
INSERT INTO users (username, email, birthdate) VALUES 
('kim', 'kim@example.com', '1996-05-15'),
('lee', 'lee@example.com', '1994-03-22');
```

**UPDATE 예제**

```sql
UPDATE users
SET email = 'kim_new@example.com'
WHERE username = 'kim';
```

**DELETE 예제**

```sql
DELETE FROM posts
WHERE title = 'Hi';
```

**외래 키 관련 옵션**

| 옵션 | 설명 |
| --- | --- |
| `CASCADE` | 참조하는 데이터도 함께 수정/삭제 |
| `SET NULL` | 참조하는 데이터를 NULL로 변경 |
| `SET DEFAULT` | 참조하는 데이터를 기본값으로 변경 |
| `RESTRICT/NO ACTION` | 수정/삭제 제한 |

---

### SELECT문 주요 구성

```sql
SELECT 필드
FROM 테이블
WHERE 조건
GROUP BY 그룹화필드
HAVING 그룹 조건
ORDER BY 정렬필드 ASC|DESC
LIMIT 시작, 개수;
```

- **WHERE** → 개별 레코드 조건
- **GROUP BY** → 필드 기준 그룹화
- **HAVING** → 그룹 조건 필터
- **ORDER BY** → 정렬
- **LIMIT** → 조회 레코드 제한

**집계 함수 예제**

| 함수 | 설명 |
| --- | --- |
| `COUNT` | 레코드 수 |
| `SUM` | 합계 |
| `AVG` | 평균 |
| `MAX` | 최대값 |
| `MIN` | 최소값 |

```sql
SELECT major, COUNT(*) AS student_count
FROM students
GROUP BY major
HAVING COUNT(*) > 1
ORDER BY student_count DESC;
```

## 트랜잭션 제어 언어(TCL)

> TCL은 **트랜잭션 단위로 작업을 관리**하는 SQL 명령어입니다.
> 

| 명령어 | 기능 |
| --- | --- |
| `COMMIT` | 변경 사항 확정 |
| `ROLLBACK` | 이전 상태로 되돌림 |
| `SAVEPOINT` | 롤백 지점 설정 |

```sql
START TRANSACTION;

UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

-- COMMIT;  -- 모든 작업을 확정
-- ROLLBACK; -- 변경 사항 취소 가능
```