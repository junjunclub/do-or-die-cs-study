# CH06. 데이터베이스

## 📌 핵심 개념 요약

- 데이터베이스의 큰 그림 (엔티티, 속성, 레코드, 필드, 스키마, 트랜잭션)
- RDBMS의 기본(필드 타입, 키, 테이블 간의 관계, 무결성 제약 조건)
- SQL(DDL, DCL, DML, TCL)

## 💡 면접 예상 질문
- 

## ❓스터디에서 논의하고 싶은 질문
- 

## 🔗 참고 자료
- **[책]** 이것이 취업을 위한 컴퓨터 과학이다 with CS 기술 면접

# 1. 데이터베이스의 큰 그림

## 데이터베이스와 DBMS

- **데이터베이스(Database)**
    - 여러 사용자가 공유·활용하기 위해 체계적으로 관리되는 데이터 집합.
    
    → 웹사이트의 학생 정보, 쇼핑몰의 결제 정보처럼 기능을 수행하는 데 꼭 필요한 데이터의 모음.
    
- **DBMS(Database Management System)**: 데이터베이스를 관리하기 위한 프로그램.
    
    → 대표 예: MySQL, PostgreSQL, Oracle, MongoDB, Redis 등.
    
    1. **RDBMS (Relational DBMS, 관계형)**
        - MySQL, Oracle, PostgreSQL, SQLite, MariaDB, MS SQL Server
        - 표(테이블) 기반, SQL 사용
    2. **NoSQL DBMS**
        - MongoDB, Redis
        - 유연한 구조, 대규모 데이터/확장성 유리

→ 현재 가장 널리 쓰이는 것은 **RDBMS**, 특히 **MySQL** 중심으로 학습 권장.

---

### 서버로서의 DBMS

- DBMS도 하나의 응용 프로그램이지만, 다른 프로그램(클라이언트)이 데이터를 요청하는 **서버 역할**을 수행.
- 클라이언트-서버 간 동작(TCP 연결)과 유사 = DBMS에 쿼리(SQL) 요청/응답.
- **SQL(Structured Query Language)**: RDBMS용 대표 언어.
    - **DDL** (CREATE, ALTER, DROP, TRUNCATE) → 데이터 정의
    - **DML** (SELECT, INSERT, UPDATE, DELETE) → 데이터 조작
    - **DCL** (COMMIT, ROLLBACK, SAVEPOINT) → 데이터 제어
    - **TCL** (GRANT, REVOKE) → 트랜잭션 제어

---

### 파일 대신 DBMS를 쓰는 이유가 무엇일까? (파일 관리의 한계)

> 암기가 필요한 내용은 아니니 그냥 가볍게 이해해보자
> 
1. **데이터 무결성/일관성 보장 어려움**
    - 여러 사용자가 동시에 접근하면 오류·불일치 발생 가능 (데이터 일관성 훼손)
    - 일일이 동기화 도구를 사용하는 것도 번거로운 일
    - 파일에 명시된 데이터에 결함이 없음을(무결함을) 일일이 검사하기도 힘듦
2. **중복 저장 증가**
    - 같은 정보가 여러 파일에 반복 저장됨 → 비효율.
3. **데이터 변경 어려움**
    - 연관된 데이터를 일일이 수정해야 함.
4. **정교한 검색 불가능**
    - 파일 검색은 단순 문자열 수준. 복잡한 조건 검색 힘듦.
5. **백업/복구 미비**
    - 파일만으로는 안정적 복구 체계 부족.

→ 따라서, **많은 데이터를 여러 사용자에게 제공하는 서비스에서는 DBMS가 훨씬 효율적**임.

## 데이터베이스의 저장 단위

### (1) 엔티티(Entity)와 속성(Attribute)

- **엔티티**: 독립적으로 존재할 수 있는 객체. 예: ‘김한빛’, ‘혼공 노트북’
- **속성**: 엔티티의 특징. 예: 이름, 나이, 제품 번호
- **엔티티 집합**: 같은 속성을 공유하는 엔티티들의 집합. 예: 구매자, 제품
    - RDBMS에서 표현되는 이차원 테이블 형태의 엔티티 집합은 릴레이션
    - NoSQL DBMS의 일종인 MongoDB에서 엔티티 집합은 컬렉션
- **도메인(Domain)**: 속성이 가질 수 있는 값의 범위. 예: 구매자 성별 속성 → {남자, 여자}

![image.png](attachment:71e5959a-e610-4e80-a97f-0f934313fc28:image.png)

### (2) 레코드(Record)와 필드(Field)

- **레코드**: 데이터베이스에 저장된 엔티티.
- **필드**: 레코드의 속성에 해당하는 데이터 항목.
- **RDBMS**: 레코드 → 행(row), 필드 → 열(column)
- **NoSQL(MongoDB)**: 레코드 → 도큐먼트(document), 필드 → JSON 키
- **차수(degree)**: 필드의 수
- **카디날리티(cardinality)**: 필드에 대한 고유 값의 수

### (3) 스키마(Schema)

> RDBMS와 NoSQL을 구분하는 주요 기준 중 하나
> 
- **스키마**: 레코드 구조와 제약 조건을 정의한 것 (레코드가 지켜야할 틀)
- **RDBMS**: 명확한 스키마 필요 → 정형화된 데이터 저장
- **NoSQL**: 스키마리스 → 자유로운 형태의 데이터 저장
    
    ```python
    {
    	"name": "hanbit",
    	"age": 30,
    	"email": "hanbit@example.com"
    }
    
    {
    	"name": "hanbit",
    	"age": 30,
    	"email": "media@example.com",
    	"address": {
    		"street": "123 Main St", "city": "Somewhere", "zipcode": "12345"
    	}
    }
    ```
    

---

## 트랜잭션(Transaction)과 ACID

### (1) 트랜잭션

- 데이터베이스와의 **논리적 상호작용 단위**
- 여러 쿼리로 구성될 수 있음. 예: A → B 5,000원 이체
    - A 계좌 잔액 감소
    - B 계좌 잔액 증가
- 초당 처리 트랜잭션 수 → TPS(Transactions Per Second)

### (2) 트랜잭션의 성질 (ACID)

> 여러 사용자/프로그램이 동시다발적으로 사용할 때 안전한 트랜잭션을 보장하는 성질
> 
1. **원자성(Atomicity)**
    - 트랜잭션의 모든 작업이 **모두 성공하거나 모두 실패**
    - ‘All or Nothing’
    - 반드시 커밋되거나 롤백되는 성질
        - 커밋(commit): 성공적으로 완료 → 영구 반영
        - 롤백(rollback): 취소 → 이전 상태로 되돌림
2. **일관성(Consistency)**
    - 트랜잭션 전후로 데이터베이스가 **규칙을 지킨 상태** 유지
    - 예: 학번 존재, 나이 ≥ 20, 이름 존재
3. **격리성(Isolation)**
    - 동시에 수행되는 트랜잭션이 **서로 간섭(레이스 컨디션)하지 않도록 보장**
    - 예: 재고가 하나인 상품을 동시에 구매할 때 문제 방지
4. **지속성(Durability)**
    - 완료된 트랜잭션 결과가 **영구적으로 저장**됨
    - 시스템 장애에도 데이터 손실 없음

![image.png](attachment:2ad93020-a27c-4e80-83b0-ef26826276c4:image.png)

---

# 2. RDBMS의 기본

---

## 테이블의 구성: 필드와 레코드

### **필드 타입(Field Type)**

- 데이터 유형을 지정하며, MySQL 기준 대표적 분류:
    - 숫자형: `TINYINT`, `SMALLINT`, `INT`, `BIGINT`, `FLOAT`, `DOUBLE`, `DECIMAL`
    - 문자형: `CHAR`, `VARCHAR`, `TEXT`, `BLOB`
    - 날짜/시간형: `DATE`, `TIME`, `DATETIME`, `TIMESTAMP`
    - 기타: `ENUM`, `GEOMETRY`, `XML`, `JSON`
    
    ![image.png](attachment:e0447d71-72ba-4c43-b294-6f11edf0cb56:image.png)
    

### 키

- 테이블 내 레코드를 식별하거나 테이블 간 참조에 사용.
- **주요 키 개념**:
    - **후보 키(Candidate Key)**
        - 레코드를 유일하게 식별할 수 있는 최소한의 필드 집합.
        - 유일성과 최소성을 모두 만족하는 키
        
        ![image.png](attachment:fc99b938-721c-4dc5-8ed1-73598abb8ba5:image.png)
        
        - 학번, 이메일, 전화번호 각각이 후보 키가 될 수 있음 (테이블 내에 하나이상 존재)
    - **복합 키(Composite Key)**
        - 두 개 이상의 필드로 구성된 후보 키.
        
        ![image.png](attachment:43eabcbf-71f9-4df1-8b6e-a0197df81c93:image.png)
        
        - {학번, 과목 코드}
    - **슈퍼 키 (Super Key)**
        - ‘필드의 최소 집합’이 아닌, 레코드를 식별하기 위한 ‘필드의 집합’
        - 유일성만 만족하고 최소성은 만족하지 않는다.
    
    ---
    
    - **기본 키(Primary Key), `PK`**
        - 후보 키 중 대표로 선택된 키, 테이블당 하나만 존재
        - 유일성과 최소성을 모두 만족
        - `NULL` 불가, 중복 불가.
    - **대체 키(Alternate Key)**
        - 기본 키로 선택되지 않은 나머지 후보 키.
    - **외래 키(Foreign Key), `FK`**
        - 다른 테이블의 기본 키를 참조하는 필드
        - 테이블 간 관계 형성.

---

## 테이블 간 관계

- **일대일(1:1)**: 한 레코드가 다른 테이블의 한 레코드와 대응.
    - 예: 승객 테이블 ↔ 여권 테이블
- **일대다(1:N)**: 한 레코드가 다른 테이블의 여러 레코드와 대응.
    - 예: 고객 테이블 ↔ 주문 테이블
- **다대다(N:M)**: 여러 레코드가 서로 여러 레코드와 대응, 보통 중간 테이블 사용.
    - 예: 사용자 테이블 ↔ 그룹 테이블 (중간 테이블: 사용자그룹)

---

## 무결성 제약 조건(Integrity Constraint)

> 데이터의 **일관성**과 **유효성**을 보장하는 규칙.
> 
1. **도메인 제약(Domain Constraint)**: 필드 타입과 값의 범위를 준수, 원자 값(Atomic Value) 유지.
2. **키 제약(Key Constraint)**: 키 필드에는 중복 값이 없어야 함.
3. **엔티티 무결성(Entity Integrity)**: 기본 키는 `NULL`이 될 수 없고, 유일해야 함.
4. **참조 무결성(Referential Integrity)**: 외래 키는 참조하는 기본 키 값과 같거나 `NULL`이어야 함.
    - 참조 대상 레코드 변경/삭제 시 RDBMS 동작:
        1. **Restrict**: 연산 거부
        2. **Set Default**: 기본값으로 설정
        3. **Set Null**: `NULL`로 설정
        4. **Cascade**: 연쇄 변경/삭제

# 3. SQL

## 데이터 정의 언어(DDL)

> DDL은 데이터베이스와 **데이터베이스 객체**를 생성, 수정, 삭제하는 SQL 명령어입니다.
> 

| 명령어 | 기능 |
| --- | --- |
| `CREATE` | 데이터베이스, 테이블, 뷰, 인덱스, 사용자 등을 생성 |
| `ALTER` | 기존 테이블/뷰/인덱스 구조를 수정 (컬럼 추가/삭제/제약 조건 변경) |
| `DROP` | 데이터베이스, 테이블, 뷰, 인덱스 삭제 |
| `TRUNCATE` | 테이블 구조는 유지하고 모든 레코드 삭제 |

### CREATE

```sql
CREATE TABLE posts (
    post_id INT PRIMARY KEY AUTO_INCREMENT, -- 필드_이름 필드_타입
    user_id INT,
    title VARCHAR(50) NOT NULL,
    content VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (user_id) REFERENCES users(user_id)
);
```

- 필드 제약 조건
    - `PRIMARY KEY` → 고유 식별자
    - `UNIQUE` → 중복 불가
    - `AUTO_INCREMENT` → 자동 증가
    - `NOT NULL` → NULL 불가
    - `DEFAULT` → 기본값 지정
- 외래 키 참조 예제
    
    ```sql
    CREATE TABLE posts (
        post_id INT PRIMARY KEY AUTO_INCREMENT,
        user_id INT,
        title VARCHAR(50) NOT NULL,
        content VARCHAR(50),
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        FOREIGN KEY (user_id) REFERENCES users(user_id)
    );
    ```
    
    외래 키(`FOREIGN KEY`)를 통해 참조 무결성 유지
    

### ALTER

```sql

-- 새로운 필드 추가
-- ALTER TABLE 테이블_이름 ADD COLUMN 필드_이름 필드_타입 [제약 조건]
ALTER TABLE posts ADD COLUMN new_field VARCHAR(50) NOT NULL;

-- 기존 필드 수정
-- ALTER TABLE 테이블_이름 CHANGE COLUMN 기존_필드_이름 새_필드_이름 필드_타입 [제약 조건]
ALTER TABLE posts CHANGE COLUMN new_field old_field VARCHAR(30) NOT NULL;

-- 기존 필드 삭제
-- ALTER TABLE 테이블_이름 DROP COLUMN 필드_이름 
ALTER TABLE posts DROP COLUMN old_field;

-- 외래 키 제약 조건 추가
-- ALTER TABLE 테이블_이름 [ADD CONSTRAINT 제약_조건_이름]
	-- ADD FOREIGN KEY (필드_이름) REFERENCES 참조_테이블_이름(참조_필드) 
	ALTER TABLE posts ADD FOREIGN KEY (user_id) REFERENCES users(user_id);

-- UNIQUE 제약 조건 추가
-- ALTER TABLE 테이블_이름 [ADD CONSTRAINT 제약_조건_이름] UNIQUE (필드_이름) 
ALTER TABLE posts ADD UNIQUE (title);

-- NOT NULL 제약 조건 추가
-- ALTER TABLE 테이블_이름 MODIFY 필드_이름 필드_타입 NOT NULL 
ALTER TABLE users MODIFY email VARCHAR(100) NOT NULL;

-- 기본 키 설정(PRIMARY KEY로 사용 중인 필드가 없을 경우
-- ALTER TABLE 테이블_이름 ADD PRIMARY KEY (필드_이름) 
ALTER TABLE posts ADD PRIMARY KEY (post_id);

```

### DROP

```sql
DROP DATABASE 데이터베이스_이름; 
DROP TABLE 테이블_이름;
```

### TRUNCATE

```sql
TRUNCATE TABLE 테이블_이름;
```

## 데이터 조작 언어(DML)

> DML은 테이블의 **데이터를 조회, 삽입, 수정, 삭제**하는 명령어입니다.
> 

| 명령어 | 기능 |
| --- | --- |
| `SELECT` | 레코드 조회 |
| `INSERT` | 레코드 삽입 |
| `UPDATE` | 레코드 수정 |
| `DELETE` | 레코드 삭제 |

**INSERT 예제**

```sql
INSERT INTO users (username, email, birthdate) VALUES 
('kim', 'kim@example.com', '1996-05-15'),
('lee', 'lee@example.com', '1994-03-22');
```

**UPDATE 예제**

```sql
UPDATE users
SET email = 'kim_new@example.com'
WHERE username = 'kim';
```

**DELETE 예제**

```sql
DELETE FROM posts
WHERE title = 'Hi';
```

**외래 키 관련 옵션**

| 옵션 | 설명 |
| --- | --- |
| `CASCADE` | 참조하는 데이터도 함께 수정/삭제 |
| `SET NULL` | 참조하는 데이터를 NULL로 변경 |
| `SET DEFAULT` | 참조하는 데이터를 기본값으로 변경 |
| `RESTRICT/NO ACTION` | 수정/삭제 제한 |

---

### SELECT문 주요 구성

```sql
SELECT 필드
FROM 테이블
WHERE 조건
GROUP BY 그룹화필드
HAVING 그룹 조건
ORDER BY 정렬필드 ASC|DESC
LIMIT 시작, 개수;
```

- **WHERE** → 개별 레코드 조건
- **GROUP BY** → 필드 기준 그룹화
- **HAVING** → 그룹 조건 필터
- **ORDER BY** → 정렬
- **LIMIT** → 조회 레코드 제한

**집계 함수 예제**

| 함수 | 설명 |
| --- | --- |
| `COUNT` | 레코드 수 |
| `SUM` | 합계 |
| `AVG` | 평균 |
| `MAX` | 최대값 |
| `MIN` | 최소값 |

```sql
SELECT major, COUNT(*) AS student_count
FROM students
GROUP BY major
HAVING COUNT(*) > 1
ORDER BY student_count DESC;
```

## 트랜잭션 제어 언어(TCL)

> TCL은 **트랜잭션 단위로 작업을 관리**하는 SQL 명령어입니다.
> 

| 명령어 | 기능 |
| --- | --- |
| `COMMIT` | 변경 사항 확정 |
| `ROLLBACK` | 이전 상태로 되돌림 |
| `SAVEPOINT` | 롤백 지점 설정 |

```sql
START TRANSACTION;

UPDATE accounts SET balance = balance - 100 WHERE account_id = 1;
UPDATE accounts SET balance = balance + 100 WHERE account_id = 2;

-- COMMIT;  -- 모든 작업을 확정
-- ROLLBACK; -- 변경 사항 취소 가능
```

# 4. 효율적 쿼리

## 서브 쿼리와 조인

### 서브 쿼리(Subquery)

**정의**

- 다른 SQL문 안에 포함된 SELECT문을 의미.
- 소괄호 `()`로 감싸 외부 쿼리와 구분.
- SELECT, INSERT, UPDATE, DELETE 등 다양한 쿼리 안에 포함 가능.

**특징**

- 외부 쿼리와 독립적으로 동작.
- 복잡한 조건이나 집계가 필요한 경우 유용.

**예시 1: SELECT 안의 서브 쿼리**

```sql
SELECT users.username,
       (SELECT COUNT(*)
        FROM posts
        WHERE posts.user_id = users.user_id) AS post_count
FROM users;
```

- 사용자의 글 개수를 조회할 때 사용.
- 외부 쿼리: `users` 테이블에서 username 조회
- 서브 쿼리: `posts` 테이블에서 해당 사용자의 글 수 조회

**예시 2: DELETE 안의 서브 쿼리**

```sql
DELETE FROM posts
WHERE user_id = (
    SELECT user_id
    FROM users
    WHERE email = 'kim@example.com'
);
```

- 특정 사용자의 글을 삭제할 때 사용.

---

### 조인(Join)

**정의**:

- 두 개 이상의 테이블을 하나로 합치는 SQL 연산.
- 서브 쿼리보다 가독성이 좋고 성능이 유리할 때 많음.

**종류**:

| 종류 | 설명 |
| --- | --- |
| **INNER JOIN** | 두 테이블에서 조인 조건을 만족하는 데이터만 결합 (교집합) |
| **LEFT OUTER JOIN** | 왼쪽 테이블의 모든 레코드 포함, 매칭 없는 오른쪽 테이블은 NULL |
| **RIGHT OUTER JOIN** | 오른쪽 테이블의 모든 레코드 포함, 매칭 없는 왼쪽 테이블은 NULL |
| **FULL OUTER JOIN** | 두 테이블의 모든 레코드 포함, 매칭 없는 부분은 NULL (MySQL은 UNION으로 구현) |

**1) INNER JOIN**

```sql
SELECT customers.name, orders.id, orders.product_id, orders.amount
FROM customers
INNER JOIN orders ON customers.id = orders.customer_id;
```

- `customers`와 `orders`에서 매칭되는 데이터만 조회.

**2) LEFT OUTER JOIN**

```sql
SELECT customers.name, orders.id AS order_id
FROM customers
LEFT OUTER JOIN orders ON customers.id = orders.customer_id;
```

- 모든 고객 포함, 주문 없는 고객은 `NULL`.

**3) FULL OUTER JOIN (MySQL에서 구현)**

```sql
SELECT customers.name, orders.id AS order_id
FROM customers
LEFT JOIN orders ON customers.id = orders.customer_id
UNION
SELECT customers.name, orders.id AS order_id
FROM customers
RIGHT JOIN orders ON customers.id = orders.customer_id;
```

- 두 테이블의 모든 데이터를 포함, 매칭 없는 값은 NULL.

**4) UNION (합집합)**

- FULL OUTER 조인 문법을 지원하지 않을 때, LEFT RIGHT OUTER JOIN의 결과를 하나로 합칠 때도 사용 가능

---

**서브 쿼리 vs. 조인**

1. **서브 쿼리**: 특정 조건이나 집계값을 조회할 때 유용, 외부 쿼리 안에서 독립적으로 실행.
2. **조인**: 여러 테이블 데이터를 하나로 결합, INNER/LEFT/RIGHT/FULL OUTER JOIN으로 나뉨.
3. **서브 쿼리 ↔ 조인**: 일부 서브 쿼리 연산은 조인으로 대체 가능하며, 조인이 성능 면에서 더 효율적일 수 있음.

## 뷰

> SELECT문의 결과를 가상의 테이블로 간주하고 다양한 SQL문 사용 → 서브쿼리
SELECT문의 결과를 토대로 SQL문을 자 주 실행해야 할 경우, 매번 서브 쿼리를 작성하기에는 중복되는 쿼리가 많아 번거롭다 → 뷰
> 

정의

- **뷰(View)** = `SELECT문 결과`로 만들어진 **가상의 테이블**
- 실제 데이터를 저장하지 않고, **쿼리 결과를 재사용**하는 개념

특징

- 복잡한 SQL문을 단순화하고 재사용 가능
- 마치 테이블처럼 조회 가능 (`SELECT`, `FROM`에서 사용)
- 실제 테이블의 데이터를 참조 → 뷰 삭제해도 원본 데이터에는 영향 없음

```sql
-- 뷰 생성
CREATE VIEW myview AS
SELECT users.username, users.email, posts.title
FROM users
JOIN posts ON users.user_id = posts.user_id;

-- 뷰 삭제
DROP VIEW myview;
```

왜 쓸까?

- **쿼리 단순화** → 복잡한 조인/조건식을 매번 쓰지 않아도 됨
- **재사용성** → 자주 쓰는 SQL 결과를 하나의 뷰로 정의
- **보안** → 특정 사용자에게 필요한 컬럼만 노출 가능

주의 사항!

- 조회(SELECT)는 자유롭게 가능
- 삽입(INSERT), 수정(UPDATE), 삭제(DELETE)는 제한될 수 있음
    - 특히 여러 테이블을 조인한 뷰는 제약 조건을 어기기 쉬우니 조심!

## 인덱스

- **검색 속도 향상**을 목적으로 특정 필드에 만든 **자료구조**
- 책의 찾아보기(index)와 유사한 개념

---

어떻게 동작할까?

- 인덱스를 만든 컬럼 기준으로 **정렬된 자료구조** 생성
- 내부적으로 주로 **B트리 / B+트리** 사용
- 인덱스를 통해 데이터 위치(포인터)로 빠르게 접근

---

- 종류
    1. **클러스터형 인덱스 (Clustered Index)**
        - 테이블당 1개
        - 기본 키(PRIMARY KEY)가 자동으로 클러스터형 인덱스가 됨
    2. **세컨더리 인덱스 (Secondary Index / Non-clustered Index)**
        - 여러 개 생성 가능
        - 조회 속도 향상은 되지만 클러스터형보다 성능은 떨어

```sql
-- 인덱스 생성
CREATE INDEX idx_user ON users(nickname);

-- 인덱스 조회
SHOW INDEX FROM users;

-- 인덱스 삭제
DROP INDEX idx_user ON users;
```

---

- 장점
    - 조회(SELECT) 성능 향상 → 대량 데이터에서 효과적
    - 특히 **WHERE, JOIN, ORDER BY**에서 자주 쓰이는 컬럼에 적합
    
    ---
    
- 단점
    - **INSERT, UPDATE, DELETE 성능 저하** → 인덱스도 갱신해야 하기 때문
    - **추가 저장 공간** 필요
    - **너무 많은 인덱스**는 성능을 오히려 악화시킴 (권장: 테이블당 3개 이하)
    - **중복 데이터가 많은 컬럼**은 인덱스 효율이 낮음

# 5. 데이터베이스 설계

## ER 다이어그램 (ERD, Entity Relationship Diagram)

- **개념**: 데이터베이스에 저장되는 엔티티(객체)와 그 관계를 시각적으로 표현한 다이어그램.
- **목적**: 데이터베이스 구조를 초기 단계에서 설계하여 유지보수와 개발자 간 소통을 원활히 함.
- **표기법**
    1. **피터 첸 표기법 (Peter Chen diagram)**
        - 엔티티 = 사각형, 관계 = 마름모, 속성 = 타원
        - 개념적 모델링에 적합, 복잡해지면 가독성이 떨어짐.
    2. **IE 표기법 (Crow’s Foot, 까마귀 발 표기법)**
        - 직관적으로 테이블 형태로 표현
        - 관계는 새 발 모양(1:1, 1:N, M:N)으로 표시
- **관계 구분**
    - **식별 관계 (Identifying)**: 참조하는 엔티티가 참조되는 엔티티 없이는 존재 불가 (실선).
    - **비식별 관계 (Non-identifying)**: 독립적으로 존재 가능 (점선).

---

## 정규화 (Normalization)

> 데이터 중복과 불일치를 줄이고, 
이상 현상(Anomaly)을 방지하기 위해 테이블을 구조화하는 과정.
> 
> 
> 잘못된 설계 → 성능 저하, 데이터 불일치 발생 방지.
> 
- **종류**
    1. **제1 정규형 (1NF)**
        - 모든 속성이 **원자값(Atomic Value)**을 가져야 함.
        - 하나의 칸에 여러 값 X.
        
        ![image.png](attachment:5396a2c3-606e-48d8-aeb1-d7e2faddee54:image.png)
        
        ---
        
        - 예시
            - 하나의 테이블로 설계
            - 테이블을 2개로 쪼개기
        
        ![image.png](attachment:3280733b-8f17-4a20-9aa8-9fea009474db:image.png)
        
        ![image.png](attachment:0afe6902-d971-4d29-8223-2ef2591bddc4:image.png)
        
    
    1. **제2 정규형 (2NF)**
        - 1NF 만족 + 기본 키의 **일부**에만 종속된 속성 제거.
        - 즉, **부분 함수 종속성 제거**.
            - 부분함수 종속성: 기본 키가 아닌 필드가 기본 키의 일부에 종속되어 있는 경우
            - 완전 함수 종속성: 기본 키 전체에 완전하게 종속되어 있는 경우
        - 예시
            
            ![image.png](attachment:00d3ba5e-69c9-4b06-8e49-c204e4fdaf72:image.png)
            
            ![image.png](attachment:ca4faac7-41ca-4803-a7dd-9aa8d33ca107:image.png)
            
    2. **제3 정규형 (3NF)
    기본키가 아닌 모든 필드는 기본 키에 대해…**
        - 2NF 만족 + **이행적 종속성 제거**.
            - 이행적 함수 종속성: 만일 어떤 테이블에 A, B, C라는 필드가 있을 때 A가 B를 결정하고(A → B) B가 C를 결정한다면 (B → C) A도 C를 결정하게 되어(A → C) 종속 관계를 형성합니다. 이때 필드 A와 C 사이에는 이 행적 종속 관계 transitive dependency, 이행 함수 종속성이 있다고 표현
        - 기본 키 아닌 속성이 다른 속성에 종속되면 안 됨.
        - 예시
            - 한 학생당 하나의 학과에 속해 있고 학과당 학과 사무실 위치가 하나뿐이라면 ‘학번’이 ‘학과’를 결정하고(학번 → 학과), ‘학과’가 ‘학과 사무실 위치’를 결정 하므로(학과 → 학과 사무실 위치), ‘학번’이 곧 ‘학과 사무실 위치’를 결정하게 됩니다(학번 → 학과사무실 위치)
            
            ![image.png](attachment:c94748ec-7af9-457d-8972-b300a21e7d39:image.png)
            
            ![image.png](attachment:317d933a-1ebf-4a9e-993c-cd8db5120cac:image.png)
            
    3. **보이스/코드 정규형 (BCNF)**
        - 3NF 만족 + 모든 **결정자가 후보 키**여야 함.
            - 결정자: 특정 필드를 식별할 수 있는 필드를 의미
        - 더 엄격한 형태.

---

## 역정규화 (Denormalization)

- 정규화를 과도하게 하면 테이블이 너무 많이 나뉘어 **JOIN이 잦아지고 성능 저하** 발생.
- 따라서 일부러 **중복 허용**하여 성능을 높이는 경우가 있음.
- NoSQL은 기본적으로 역정규화 구조를 채택.

# 6. NoSQL

## RDBMS vs NoSQL 정리

### RDBMS

- 데이터를 **테이블(행·열)** 형태로 저장
- **SQL** 언어 사용
- **ACID**(원자성, 일관성, 고립성, 지속성) 보장
- 스키마 고정 → 정형 데이터에 적합
- **정규화·조인** 적극 활용

---

### NoSQL

- **Not Only SQL** (비관계형 데이터베이스)
- 다양한 데이터 구조 지원 (테이블 이외)
- **스키마 자유로움** (정형/반정형/비정형 데이터 저장 가능)
- **수평적 확장(스케일 아웃)** 용이
- **높은 성능, 가용성, 확장성, 유연성**
- ACID 엄격히 보장 X → 대신 성능 중시 (무결성·일관성 일부 희생)
- 대규모 분산 환경, 비정형 데이터 처리에 적합
- RDBMS 완전 대체 X→ 상황에 따라 선택

---

### NoSQL 주요 유형

1. **키-값 데이터베이스**
    - 구조: `Key : Value`
    - 대표: **Redis, Memcached**
    - 특징: 단순 구조, 빠른 속도 (메모리 기반 → 인메모리 DB)
    - 활용: 캐시, 세션 관리
2. **도큐먼트 데이터베이스**
    - 구조: JSON, BSON, XML 형태의 **도큐먼트 단위**
    - 대표: **MongoDB**
    - 특징: 스키마 자유로움, 컬렉션 단위로 관리
    - 활용: 유연한 데이터 모델 필요할 때
3. **그래프 데이터베이스**
    - 구조: **노드-엣지(관계)**
    - 대표: **Neo4j**
    - 특징: 데이터 간 관계를 효율적으로 표현 (SNS, 교통망 등)
4. **칼럼 패밀리 데이터베이스**
    - 구조: 행(Row), 열(Column) + 로우 키(Row Key)
    - 대표: **Cassandra, HBase**
    - 특징: 스키마 유연, 정규화·조인 없음
    - 활용: 대규모 데이터 처리, 분산 환경

---

### MongoDB 기본 명령 예시

- DB/컬렉션 생성:
    
    `use mydb`, `db.createCollection("mycollection")`
    
- 데이터 삽입:
    
    `insertOne()`, `insertMany()`
    
- 조회:
    
    `find()`, 연산자 (`$eq`, `$gt`, `$and` 등)
    
- 갱신:
    
    `updateOne()`, `updateMany()` (`$set`, `$unset`)
    
- 삭제:
    
    `deleteOne()`, `deleteMany()`
    

---

### Redis 기본 명령 예시

- 문자열:
    
    `SET`, `GET`, `SETNX`, `MGET`, `DEL`
    
- 리스트:
    
    `LPUSH`, `RPUSH`, `LPOP`, `RPOP`, `LRANGE`, `LLEN`
    
- 특징: 다양한 자료구조 지원 (문자열, 리스트, 해시, 집합)

---

<aside>
<img src="/icons/checkmark_blue.svg" alt="/icons/checkmark_blue.svg" width="40px" />

- **RDBMS**: 정형 데이터, ACID 보장, 안정적 → 은행·회계 등
- **NoSQL**: 비정형/대용량 데이터, 성능·확장성·유연성 중시 → SNS·빅데이터·실시간 처리
- **둘은 대체 관계가 아님**, 상황에 맞춰 병행/선택적으로 사용
</aside>