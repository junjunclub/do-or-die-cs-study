데이터베이스

- 여러 사람이 공유하여 사용할 목적으로 체계화해 통합, 관리하는 데이터의 집합

> 원하는 기능을 동작시키기 위해 마땅히 저장해야 하는 정보의 집합

DBMS란 데이터베이스를 관리하기 위한 수단

기본적으로 클라이언트-서버 통신과 유사하고 TCP 통신을 활용함

| 종류                                   | 명령        | 설명                                        |
| -------------------------------------- | ----------- | ------------------------------------------- |
| **DDL** (Data Definition Language)     | `CREATE`    | 데이터베이스 객체 생성 (TABLE, VIEW 등)     |
|                                        | `ALTER`     | 기존 객체 구조 변경                         |
|                                        | `DROP`      | 객체 삭제                                   |
|                                        | `TRUNCATE`  | 테이블 데이터 전체 삭제(구조는 유지)        |
| **DML** (Data Manipulation Language)   | `SELECT`    | 데이터 조회                                 |
|                                        | `INSERT`    | 새로운 데이터 삽입                          |
|                                        | `UPDATE`    | 기존 데이터 수정                            |
|                                        | `DELETE`    | 기존 데이터 삭제                            |
| **DCL** (Data Control Language)        | `GRANT`     | 사용자에게 권한 부여                        |
|                                        | `REVOKE`    | 사용자 권한 회수                            |
| **TCL** (Transaction Control Language) | `COMMIT`    | 트랜잭션 확정 (변경사항 저장)               |
|                                        | `ROLLBACK`  | 트랜잭션 취소 (변경 전 상태로 복원)         |
|                                        | `SAVEPOINT` | 트랜잭션 내 특정 지점 저장 (부분 롤백 가능) |
|                                        |             |                                             |

왜 파일 시스템 대신 데이터베이스를 쓸까?

1. 데이터 일관성 및 무결성 제공이 어려움
   1. 동시다발적 요청을 처리하기에 `레이스 컨디션` 발생 여지
   2. 데이터의 일관성 훼손 가능성
   3. 잘못된 값을 검출하기 어려움
2. 불필요한 중복 저장이 많아짐
   1. ex) 컬럼들을 중복해서 활용
3. 데이터 변경 시 연관 데이터 변경이 어려움
4. 정교한 검색이 어려움
5. 백업 및 복구가 어려움

#### 데이터베이스 저장 단위와 트랜잭션

- 엔티티, 스키마, 트랜잭션

##### 데이터베이스 저장 단위

- 엔티티: 독립적으로 존재할 수 있는 객체

RDBMS에서 엔티티의 집합은 릴레이션
NoSQL에서는 엔티티의 집합을 컬렉션

기록된 엔티티를 레코드
저장된 엔티티의 속성을 필드

![[Pasted image 20250909184347.png]]

---

##### 스키마

- 데이터베이스에 저장되는 레코드의 구조와 제약 조건을 정의한 것
- 레코드가 지켜야 할 틀, 청사진

NoSQL에서는 명확한 스키마가 정의되지 않기 때문에 NoSQL 데이터베이스를 스키마리스 데이터베이스라고 함.

고정된 스키마를 따르지 않아 더욱 유연한 형태로 레코드를 관리할 수 있음.

##### 트랜잭션과 ACID

트랜잭션이란?

- 데이터베이스와의 논리적 상호작용의 단위
- 처리하는 단위를 나타내며, 작업 성능을 나타내기도 함.

**트랜잭션을 보장하기 위해 지켜야하는 성질 4가지**

- 원자성(Atomicity)
  - 하나의 트랜잭션 결과가 모두 성공하거나 모두 실패하는 성질
- 일관성(Consistency)
  - 트랜잭션 전후로 데이터베이스가 일관된 상태를 유지하는 성질
- 격리성(Solidation)
  - 동시에 수행되는 여러 트랜잭션이 서로 간섭하지 않도록 보장하는 성질
    - 레이스 컨디션 방지
- 지속성(Duarabliity)
  - 트랜잭션이 성공적으로 완료된 후에 그 결과가 영구적으로 반영되는 성질
  - 시스템 장애가 발생하더라도 완료된 트랜잭션의 결과는 손실되지 않아야 함.

### RDBMS의 기본

#### 테이블의 구성: 필드와 레코드

- 각 필드로 사용가능한 데이터 유형이 있음. 이를 필드 타입이라고 함.
  - 특정 레코드를 식별할 수 있는 필드의 집합은 `키`

##### 필드타입

- 다양한 데이터 형식이 있음.

![[Pasted image 20250909191453.png]]

##### 키

- 각 레코드는 어떤 필드로 식별 할 수 있을까?
- 레코드의 조합으로.
- 레코드를 식별할 수 있는 하나 이상의 필드를 키 라고 함.
- 테이블 간 참조를 위해 사용되기도 함.

**후보 키 : 유일성과 최소성을 모두 만족하는 키**
**복합 키: 두 필드 이상으로 구성된 후보 키**
**기본 키: 한 레코드를 식별하도록 선정되어 테이블당 하남나 존재할 수 있는 키**

기본 키가 아닌 후보 키는 대체 키라고 함.

**외래 키: 다른 테이블의 기본 키를 참조하는 필드**

#### 테이블의 관계

일대일, 일대다, 다대다

#### 일대일 대응 관계

- 하나의 레코드가 다른 테이블의 레코드 하나에만 대응되는 경우

#### 일대다 대응 관계

- 하나의 레코드가 다른 테이블의 여러 레코드와 대응될 수 있는 경우

#### 다대다 대응 관계

- 한 테이블의 여러 레코드가 다른 테이블의 여러 레코드와 대응되는 경우
- 일반적으로 중간 테이블을 수반함

### 무결성 제약 조건

- 무결성이란 일관되며 유효한 데이터의 상태
- 무결성 제약 조건이란 데이터베이스에 저장된 데이터의 일관성과 유효성을 유지하기 위해 마땅히 지켜야 하는 조건을 의미함.

##### 도메인 제약 조건

- 테이블이 가질 수 있는 필드 타입과 범위에 대한 규칙
- 각각의 필드 데이터는 원자 값을 가져야하고, 지정된 필드 타입을 준수해야하며ㅡ 값의 범위나 기본값이 지정되었을 경우 그를 따라야함.

![[Pasted image 20250909192313.png]]

##### 키 제약 조건

- 레코드를 고유하게 식별할 수 있는 키로 지정된 필드에 중복된 값이 존재해서는 안된다는 제약조건

##### 엔티티 무결성 제약 조건

- 기본 키로 지정한 필드는 고유한 값이어야 하며, NULL이 되어서는 안된다는 규칙

##### 참조 무결성 제약 조건

- 외래 키를 통해 다른 테이블을 참조할 때 데이터의 일관성을 지키기 위한 제약조건으로 외래 키는 참조하는 테이블의 기본 키와 같은 값을 갖거나 NULL값을 가져야 한다는 규칙

### SQL

**DDL, DML, DCL, TCL**

---

#### 🔹 DDL (데이터 정의 언어, Data Definition Language)

데이터베이스 **구조(스키마)** 를 정의/수정/삭제하는 명령어.

- **CREATE** : 데이터베이스 객체(테이블, 뷰, 인덱스, 사용자 등) 생성
- **ALTER** : 기존 객체의 구조 변경 (컬럼 추가/수정/삭제, 제약조건 CUD)
- **DROP** : 객체 삭제 (CASCADE 옵션 시 의존 객체도 함께 삭제)
- **TRUNCATE** : 테이블 구조는 유지, 데이터만 전부 삭제 (롤백 불가 → DDL 성격)

> 특징: 자동 COMMIT 발생 → 실행하면 바로 반영, ROLLBACK 불가

---

#### 🔹 DML (데이터 조작 언어, Data Manipulation Language)

테이블 안의 **데이터를 조회/조작**하는 명령어.

- **SELECT** : 데이터 조회
- **INSERT** : 새로운 레코드 삽입
  - 지정하지 않은 컬럼은 `NULL` 또는 `DEFAULT` 값으로 채워짐
  - 무결성 제약조건 준수 필요
- **UPDATE** : 기존 레코드 수정
  - `WHERE` 절 없으면 전체 데이터가 수정됨 (주의⚠️)
- **DELETE** : 기존 레코드 삭제
  - `WHERE` 절 없으면 전체 데이터 삭제됨 (⚠️)
  - 하지만 구조는 유지, ROLLBACK 가능

---

#### 🔹 DCL (데이터 제어 언어, Data Control Language)

데이터베이스에 대한 **권한(Privilege)** 및 보안 제어.

- **GRANT** : 특정 사용자에게 권한 부여 (예: `SELECT`, `INSERT`, `UPDATE` 권한)
- **REVOKE** : 특정 사용자 권한 회수
- **DENY** : 특정 권한 거부 (DBMS마다 지원 여부 다름)

---

#### 🔹 TCL (트랜잭션 제어 언어, Transaction Control Language)

트랜잭션 단위로 데이터 조작을 제어. (**원자성/일관성/격리성/지속성 = ACID 보장**)

- **COMMIT** : 현재 트랜잭션에서 수행한 변경 사항을 DB에 영구 반영
- **ROLLBACK** : 트랜잭션 내 변경 사항 취소 (마지막 COMMIT 시점으로 복구)
- **SAVEPOINT** : 트랜잭션 내 특정 지점 저장 → 필요 시 해당 지점까지 ROLLBACK 가능

---

### 정리표

| 구분    | 명령어                         | 설명                       | 특징                       |
| ------- | ------------------------------ | -------------------------- | -------------------------- |
| **DDL** | CREATE, ALTER, DROP, TRUNCATE  | 데이터 구조 정의/수정/삭제 | 자동 COMMIT, ROLLBACK 불가 |
| **DML** | SELECT, INSERT, UPDATE, DELETE | 데이터 조회/조작           | ROLLBACK 가능              |
| **DCL** | GRANT, REVOKE, DENY            | 사용자 권한 제어           | 보안/접근 제어             |
| **TCL** | COMMIT, ROLLBACK, SAVEPOINT    | 트랜잭션 제어              | ACID 보장                  |

---

## 🔹 실행 순서 .

SQL의 논리적 실행 순서에서 중요한 부분만 뽑으면:

1. **FROM / JOIN** – 데이터 소스 확정
2. **WHERE** – 행(레코드) 필터링
3. **GROUP BY** – 그룹화 수행
4. **HAVING** – 그룹화된 결과에 조건 적용 (집계 함수 조건 가능)
5. **SELECT** – 컬럼/집계 결과 선택
6. **ORDER BY** – 정렬
7. **LIMIT** – 최종 출력 개수 제한

즉,

- `WHERE` → 그룹화 전 조건
- `HAVING` → 그룹화 후 조건
- `LIMIT` → 최종 결과 행 개수 제한

---

## 🔹 GROUP BY

- 특정 컬럼을 기준으로 행을 묶음.
- 집계 함수(`COUNT`, `SUM`, `AVG`, `MAX`, `MIN`)와 함께 자주 사용.

```sql
SELECT department, COUNT(*) AS cnt
FROM employees
GROUP BY department;
```

---

## 🔹 HAVING

- `WHERE`와 달리, **집계 결과**를 조건으로 걸 때 사용.

```sql
SELECT department, COUNT(*) AS cnt
FROM employees
GROUP BY department
HAVING COUNT(*) >= 5;
```

`WHERE COUNT(*) >= 5` 는 불가능 (집계 전 단계라 COUNT 사용 불가)

---

## 🔹 LIMIT

- 출력되는 결과 행 수 제한. (MySQL, PostgreSQL 등에서 지원)
- Oracle은 `ROWNUM` 또는 `FETCH FIRST n ROWS ONLY` 사용.

```sql
SELECT department, COUNT(*) AS cnt
FROM employees
GROUP BY department
HAVING COUNT(*) >= 5
ORDER BY cnt DESC
LIMIT 3;
```

부서별 인원 수가 5명 이상인 경우만 출력하고, 인원 수 많은 상위 3개 부서만 출력.

---

## 정리

- `GROUP BY` → 그룹을 묶는다
- `HAVING` → 그룹화된 결과에 조건을 건다
- `LIMIT` → 최종 결과에서 개수를 제한한다

---

# 효율적 쿼리

- 서브 쿼리, 조인, 뷰, 인덱스

## 서브 쿼리와 조인

- 서브 쿼리는 다른 SQL문이 포한된 SQL문을 의미
- 조인은 2개의 테이블을 하나로 합치는 것을 의미

### 여러 테이블의 질의하기

- 하나의 select 문으로 여러 테이블의 레코드를 조회

```sql
select 테이블1.필드1, 테이블2.필드3
from 테이블1, 테이블2
where 테이블1.필드1 = 테이블2.필드2;
```

### 서브 쿼리

`내부에 다른 SQL문이 포함되어 있는 SQL문`

대표적인 2가지 유형

- select 문 안에 select 문이 포함된 서브 쿼리
- delete 문 안에 select 문이 포함된 서브 쿼리

### 조인

- 여러 테이블을 하나로 합치는 것을 의미

![[Pasted image 20250916152353.png]]

## 뷰

- select 문의 결과로 만들어진 가상의 테이블
- select 문의 결과를 뷰로 생성한 뒤, 해당 뷰에 다양한 SQL문을 실행해 볼 수 있음.
- 특정 사용자에게만 해당 뷰에 대한 접근 권한을 부여
- insert, updae, delete 불가

## 인덱스

- RDBMS의 성능을 향상시키는 가장 대중적인 방법
- 검색 속도 향상을 목적으로 만드는 하나 이상의 테이블 필드에 대한 자료구조

인덱스는 B트리 형태를 띔.

MySQL에서는 크게 클러스터형 인덱스와 세컨더리 인덱스로 구분함.
클러스터 인덱스: 테이블당 하나씩 만들 수 있는 인덱
PK == 클러스터 인덱스

```
if(PK is null) => cluster index = field(NotNUll, Unique)
```

클러스터가 아닌 인덱스를 세컨더리 인덱스 라고 함.
세컨더리 인덱스 == 논클러스터형 인덱스

테이블에 여러개 존재 가능. but 클러스터형 인덱스 보다 느림.

테이블당 3개이하 인덱스를 권고함.
인덱스가 많아질수록 삽입 수정 삭제가 많아지면 비용이 커짐.

# 데이터베이스 설계

## ER다이어그램

데이터베이스를 구성하는 요소들의 관계를 나타내는 그림이
엔티티 관계를 표한하는 ER다이어그램.

식별 비식별?

```mermaid
erDiagram
    ORDER {
        int order_id PK
        int user_id
    }
    ORDER_ITEM {
        int order_id PK, FK
        int product_id PK
        int quantity
    }
    USER {
        int user_id PK
        string name
    }
    POST {
        int post_id PK
        int user_id FK
        string title
    }

    ORDER ||--o{ ORDER_ITEM : "식별 관계 (Identifying)"
    USER  ||--o{ POST       : "비식별 관계 (Non-identifying)"

```

# 정규화

제1~5정규화

## 제1 정규형

- 모든 속성이 원자 값을 가진다는 것.

> 중복된 데이터가 없어야함.

![[Pasted image 20250916161358.png]]
![[Pasted image 20250916161403.png]]

## 제2 정규형

- 1정규형을 만족, 기본 키가 아닌 모든 필드들이 모든 기본 키에 완전히 종속되어야함.
- 보통 기본 키가 2개 이상의 필드로 구성될 때 고려됨.

기본 키가 아닌 필드가 기본 키의 일부에 종속되어 있는 경우 **부분 함수 종속성**이 있다고 표현함
기본 키 전체에 완전하게 종속되어 있는 경우 **완전 함수 종속성**이라고 함.

제2 정규형은 **부분 함수 종속성이 없는 상태** 임.

> **기본키 일부에만 종속되는 컬럼(부분 함수 종속)이 없어야 한다.**  
>  만약 있으면, 그 컬럼은 독립된 테이블로 분리해야 한다.

![[Pasted image 20250916161706.png]]
![[Pasted image 20250916161710.png]]

## 제3 정규형

- 제2 정규형을 만족하면서, 기본 키가 아닌 모든 필드가 기본 키에 이행적 종속성이 없는 상태
- 어떤 컬림이 기본키 -> 다른 컬럼 -> 또 다른 컬럼으로 간접적으로 종속되는 관계를 말함.
- 즉, A가 B를 결정하고, B가 C를 결정한다면, A -> C는 이행적 종속이라고 부름.
  ![[Pasted image 20250916165012.png]]

![[Pasted image 20250916165019.png]]

## 보이스/코드 정규형

- 제3 정규형을 만족하는 동시에 모든 결정자가 후보 키여야한다는 조건
- 결정자란 특정 필드를 식별할 수 있는 필드를 의미함.
- 어떤 컬럼이 다른 컬럼을 결정한다면, 그 컬럼은 반드시 후보키여야 한다

과목 코드랑 담당 교수랑 항상 같앙서? 담당교수의 결정자가 과목코드

![[Pasted image 20250916170243.png]]

# NoSQL

## 키-값 데이터베이스

Redis or Memcached
인메모리 데이터베이스

## 도큐먼트 데이터베이스

정형화되어 있지 않은 NoSQL
유연한 스키마를 가질 수있음.

## 그래프 데이터페이스

neo4j
데이터를 그래프의 노드 형태로 저장하는 데이터베이스
노드 간의 연결 관계와 방향을 표현할 수 있기 때문에 SNS의 친구 관계나 교통망과 같이 데이터 간의 관계성이 중요한 레코드를 저장

## 칼럼 패밀리 데이터베이스

Cassandra, HBase
행과 열이 있고, 로우 키를 통해 특정 행을 식별함.

관련있는 열들이 모여 칼럼 패밀리라는 단위를 형성
칼럼패밀리는 키스페이스라는 단위를 형성

정리: NoSQL은 높은 부하를 감당하거나, 대용량 데이터를 다루는 분산 환경에서 좋음.
스케일 아웃을 하기 편함.

---

Q. view를 쓰면 성능 최적화가 일어나는가요?
A. 일반 **VIEW**는 단순히 SQL 쿼리 정의를 저장한 **가상 테이블**일 뿐이므로, 성능 최적화 효과는 없습니다. VIEW를 조회할 때마다 원본 테이블에 대해 동일한 JOIN/집계 쿼리가 실행되기 때문에, 직접 쿼리를 작성하는 것과 성능상 차이가 없습니다.

Q. 식별과 비식별 관계가 무엇인가?
A. **식별 관계는 부모 키가 자식의 PK에 포함되는 강한 종속 관계이고, 비식별 관계는 자식이 독립적인 PK를 가지며 부모 키를 단순 FK로만 두는 느슨한 관계입니다.** 식별 관계는 보통 상세 테이블이나 조인 테이블에 쓰이고, 비식별 관계는 일반적인 엔티티 간 참조에서 주로 사용됩니다.

Q. 언제 역정규화를 해야할까요?
A. **역정규화는 성능 최적화를 위해, 정규화된 구조로 인한 조회 성능 저하가 발생할 때 적용합니다.**  
JOIN이 과도하거나, 집계 연산이 빈번하거나, 특정 조회 패턴이 반복되는 경우, 중복 컬럼·요약 테이블·데이터 마트 등을 추가하여 조회 속도를 개선할 수 있습니다.
