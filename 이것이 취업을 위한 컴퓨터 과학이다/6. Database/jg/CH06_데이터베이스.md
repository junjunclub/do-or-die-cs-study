데이터베이스

- 여러 사람이 공유하여 사용할 목적으로 체계화해 통합, 관리하는 데이터의 집합

> 원하는 기능을 동작시키기 위해 마땅히 저장해야 하는 정보의 집합

DBMS란 데이터베이스를 관리하기 위한 수단

기본적으로 클라이언트-서버 통신과 유사하고 TCP 통신을 활용함

| 종류                                   | 명령        | 설명                                        |
| -------------------------------------- | ----------- | ------------------------------------------- |
| **DDL** (Data Definition Language)     | `CREATE`    | 데이터베이스 객체 생성 (TABLE, VIEW 등)     |
|                                        | `ALTER`     | 기존 객체 구조 변경                         |
|                                        | `DROP`      | 객체 삭제                                   |
|                                        | `TRUNCATE`  | 테이블 데이터 전체 삭제(구조는 유지)        |
| **DML** (Data Manipulation Language)   | `SELECT`    | 데이터 조회                                 |
|                                        | `INSERT`    | 새로운 데이터 삽입                          |
|                                        | `UPDATE`    | 기존 데이터 수정                            |
|                                        | `DELETE`    | 기존 데이터 삭제                            |
| **DCL** (Data Control Language)        | `GRANT`     | 사용자에게 권한 부여                        |
|                                        | `REVOKE`    | 사용자 권한 회수                            |
| **TCL** (Transaction Control Language) | `COMMIT`    | 트랜잭션 확정 (변경사항 저장)               |
|                                        | `ROLLBACK`  | 트랜잭션 취소 (변경 전 상태로 복원)         |
|                                        | `SAVEPOINT` | 트랜잭션 내 특정 지점 저장 (부분 롤백 가능) |
|                                        |             |                                             |

왜 파일 시스템 대신 데이터베이스를 쓸까?

1. 데이터 일관성 및 무결성 제공이 어려움
   1. 동시다발적 요청을 처리하기에 `레이스 컨디션` 발생 여지
   2. 데이터의 일관성 훼손 가능성
   3. 잘못된 값을 검출하기 어려움
2. 불필요한 중복 저장이 많아짐
   1. ex) 컬럼들을 중복해서 활용
3. 데이터 변경 시 연관 데이터 변경이 어려움
4. 정교한 검색이 어려움
5. 백업 및 복구가 어려움

#### 데이터베이스 저장 단위와 트랜잭션

- 엔티티, 스키마, 트랜잭션

##### 데이터베이스 저장 단위

- 엔티티: 독립적으로 존재할 수 있는 객체

RDBMS에서 엔티티의 집합은 릴레이션
NoSQL에서는 엔티티의 집합을 컬렉션

기록된 엔티티를 레코드
저장된 엔티티의 속성을 필드

![[Pasted image 20250909184347.png]]

---

##### 스키마

- 데이터베이스에 저장되는 레코드의 구조와 제약 조건을 정의한 것
- 레코드가 지켜야 할 틀, 청사진

NoSQL에서는 명확한 스키마가 정의되지 않기 때문에 NoSQL 데이터베이스를 스키마리스 데이터베이스라고 함.

고정된 스키마를 따르지 않아 더욱 유연한 형태로 레코드를 관리할 수 있음.

##### 트랜잭션과 ACID

트랜잭션이란?

- 데이터베이스와의 논리적 상호작용의 단위
- 처리하는 단위를 나타내며, 작업 성능을 나타내기도 함.

**트랜잭션을 보장하기 위해 지켜야하는 성질 4가지**

- 원자성(Atomicity)
  - 하나의 트랜잭션 결과가 모두 성공하거나 모두 실패하는 성질
- 일관성(Consistency)
  - 트랜잭션 전후로 데이터베이스가 일관된 상태를 유지하는 성질
- 격리성(Solidation)
  - 동시에 수행되는 여러 트랜잭션이 서로 간섭하지 않도록 보장하는 성질
    - 레이스 컨디션 방지
- 지속성(Duarabliity)
  - 트랜잭션이 성공적으로 완료된 후에 그 결과가 영구적으로 반영되는 성질
  - 시스템 장애가 발생하더라도 완료된 트랜잭션의 결과는 손실되지 않아야 함.

### RDBMS의 기본

#### 테이블의 구성: 필드와 레코드

- 각 필드로 사용가능한 데이터 유형이 있음. 이를 필드 타입이라고 함.
  - 특정 레코드를 식별할 수 있는 필드의 집합은 `키`

##### 필드타입

- 다양한 데이터 형식이 있음.

![[Pasted image 20250909191453.png]]

##### 키

- 각 레코드는 어떤 필드로 식별 할 수 있을까?
- 레코드의 조합으로.
- 레코드를 식별할 수 있는 하나 이상의 필드를 키 라고 함.
- 테이블 간 참조를 위해 사용되기도 함.

**후보 키 : 유일성과 최소성을 모두 만족하는 키**
**복합 키: 두 필드 이상으로 구성된 후보 키**
**기본 키: 한 레코드를 식별하도록 선정되어 테이블당 하남나 존재할 수 있는 키**

기본 키가 아닌 후보 키는 대체 키라고 함.

**외래 키: 다른 테이블의 기본 키를 참조하는 필드**

#### 테이블의 관계

일대일, 일대다, 다대다

#### 일대일 대응 관계

- 하나의 레코드가 다른 테이블의 레코드 하나에만 대응되는 경우

#### 일대다 대응 관계

- 하나의 레코드가 다른 테이블의 여러 레코드와 대응될 수 있는 경우

#### 다대다 대응 관계

- 한 테이블의 여러 레코드가 다른 테이블의 여러 레코드와 대응되는 경우
- 일반적으로 중간 테이블을 수반함

### 무결성 제약 조건

- 무결성이란 일관되며 유효한 데이터의 상태
- 무결성 제약 조건이란 데이터베이스에 저장된 데이터의 일관성과 유효성을 유지하기 위해 마땅히 지켜야 하는 조건을 의미함.

##### 도메인 제약 조건

- 테이블이 가질 수 있는 필드 타입과 범위에 대한 규칙
- 각각의 필드 데이터는 원자 값을 가져야하고, 지정된 필드 타입을 준수해야하며ㅡ 값의 범위나 기본값이 지정되었을 경우 그를 따라야함.

![[Pasted image 20250909192313.png]]

##### 키 제약 조건

- 레코드를 고유하게 식별할 수 있는 키로 지정된 필드에 중복된 값이 존재해서는 안된다는 제약조건

##### 엔티티 무결성 제약 조건

- 기본 키로 지정한 필드는 고유한 값이어야 하며, NULL이 되어서는 안된다는 규칙

##### 참조 무결성 제약 조건

- 외래 키를 통해 다른 테이블을 참조할 때 데이터의 일관성을 지키기 위한 제약조건으로 외래 키는 참조하는 테이블의 기본 키와 같은 값을 갖거나 NULL값을 가져야 한다는 규칙

### SQL

**DDL, DML, DCL, TCL**

---

#### 🔹 DDL (데이터 정의 언어, Data Definition Language)

데이터베이스 **구조(스키마)** 를 정의/수정/삭제하는 명령어.

- **CREATE** : 데이터베이스 객체(테이블, 뷰, 인덱스, 사용자 등) 생성
- **ALTER** : 기존 객체의 구조 변경 (컬럼 추가/수정/삭제, 제약조건 CUD)
- **DROP** : 객체 삭제 (CASCADE 옵션 시 의존 객체도 함께 삭제)
- **TRUNCATE** : 테이블 구조는 유지, 데이터만 전부 삭제 (롤백 불가 → DDL 성격)

> 특징: 자동 COMMIT 발생 → 실행하면 바로 반영, ROLLBACK 불가

---

#### 🔹 DML (데이터 조작 언어, Data Manipulation Language)

테이블 안의 **데이터를 조회/조작**하는 명령어.

- **SELECT** : 데이터 조회
- **INSERT** : 새로운 레코드 삽입
  - 지정하지 않은 컬럼은 `NULL` 또는 `DEFAULT` 값으로 채워짐
  - 무결성 제약조건 준수 필요
- **UPDATE** : 기존 레코드 수정
  - `WHERE` 절 없으면 전체 데이터가 수정됨 (주의⚠️)
- **DELETE** : 기존 레코드 삭제
  - `WHERE` 절 없으면 전체 데이터 삭제됨 (⚠️)
  - 하지만 구조는 유지, ROLLBACK 가능

---

#### 🔹 DCL (데이터 제어 언어, Data Control Language)

데이터베이스에 대한 **권한(Privilege)** 및 보안 제어.

- **GRANT** : 특정 사용자에게 권한 부여 (예: `SELECT`, `INSERT`, `UPDATE` 권한)
- **REVOKE** : 특정 사용자 권한 회수
- **DENY** : 특정 권한 거부 (DBMS마다 지원 여부 다름)

---

#### 🔹 TCL (트랜잭션 제어 언어, Transaction Control Language)

트랜잭션 단위로 데이터 조작을 제어. (**원자성/일관성/격리성/지속성 = ACID 보장**)

- **COMMIT** : 현재 트랜잭션에서 수행한 변경 사항을 DB에 영구 반영
- **ROLLBACK** : 트랜잭션 내 변경 사항 취소 (마지막 COMMIT 시점으로 복구)
- **SAVEPOINT** : 트랜잭션 내 특정 지점 저장 → 필요 시 해당 지점까지 ROLLBACK 가능

---

### 정리표

| 구분    | 명령어                         | 설명                       | 특징                       |
| ------- | ------------------------------ | -------------------------- | -------------------------- |
| **DDL** | CREATE, ALTER, DROP, TRUNCATE  | 데이터 구조 정의/수정/삭제 | 자동 COMMIT, ROLLBACK 불가 |
| **DML** | SELECT, INSERT, UPDATE, DELETE | 데이터 조회/조작           | ROLLBACK 가능              |
| **DCL** | GRANT, REVOKE, DENY            | 사용자 권한 제어           | 보안/접근 제어             |
| **TCL** | COMMIT, ROLLBACK, SAVEPOINT    | 트랜잭션 제어              | ACID 보장                  |

---

## 🔹 실행 순서

SQL의 논리적 실행 순서에서 중요한 부분만 뽑으면:

1. **FROM / JOIN** – 데이터 소스 확정
2. **WHERE** – 행(레코드) 필터링
3. **GROUP BY** – 그룹화 수행
4. **HAVING** – 그룹화된 결과에 조건 적용 (집계 함수 조건 가능)
5. **SELECT** – 컬럼/집계 결과 선택
6. **ORDER BY** – 정렬
7. **LIMIT** – 최종 출력 개수 제한

즉,

- `WHERE` → 그룹화 전 조건
- `HAVING` → 그룹화 후 조건
- `LIMIT` → 최종 결과 행 개수 제한

---

## 🔹 GROUP BY

- 특정 컬럼을 기준으로 행을 묶음.
- 집계 함수(`COUNT`, `SUM`, `AVG`, `MAX`, `MIN`)와 함께 자주 사용.

```sql
SELECT department, COUNT(*) AS cnt
FROM employees
GROUP BY department;
```

---

## 🔹 HAVING

- `WHERE`와 달리, **집계 결과**를 조건으로 걸 때 사용.

```sql
SELECT department, COUNT(*) AS cnt
FROM employees
GROUP BY department
HAVING COUNT(*) >= 5;
```

`WHERE COUNT(*) >= 5` 는 불가능 (집계 전 단계라 COUNT 사용 불가)

---

## 🔹 LIMIT

- 출력되는 결과 행 수 제한. (MySQL, PostgreSQL 등에서 지원)
- Oracle은 `ROWNUM` 또는 `FETCH FIRST n ROWS ONLY` 사용.

```sql
SELECT department, COUNT(*) AS cnt
FROM employees
GROUP BY department
HAVING COUNT(*) >= 5
ORDER BY cnt DESC
LIMIT 3;
```

부서별 인원 수가 5명 이상인 경우만 출력하고, 인원 수 많은 상위 3개 부서만 출력.

---

## 정리

- `GROUP BY` → 그룹을 묶는다
- `HAVING` → 그룹화된 결과에 조건을 건다
- `LIMIT` → 최종 결과에서 개수를 제한한다

---
